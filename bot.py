import asyncio
import os
import logging
import json
from dotenv import load_dotenv

# Load environment variables
load_dotenv()

from aiogram import Bot, Dispatcher, Router, types, F
from aiogram.filters import Command, StateFilter
from aiogram.fsm.context import FSMContext
from aiogram.fsm.state import State, StatesGroup
from aiogram.types import ReplyKeyboardMarkup, KeyboardButton, InlineKeyboardMarkup, InlineKeyboardButton, LinkPreviewOptions, InlineQuery, InlineQueryResultArticle, InputTextMessageContent
from aiogram.enums import ParseMode
from database import (init_db, add_user, get_all_users, save_broadcast, log_click, get_stats,
                      update_button_content, get_button_content, get_all_keyboard_buttons,
                      add_keyboard_button, delete_keyboard_button, rename_keyboard_button)

# Load chat continuation texts
CHATS_CONTINUATION_FILE = "chats_continuation.json"
CHATS_CONTINUATION = {}


def load_chats_continuation():
    global CHATS_CONTINUATION
    try:
        if os.path.exists(CHATS_CONTINUATION_FILE):
            with open(CHATS_CONTINUATION_FILE, 'r', encoding='utf-8') as f:
                CHATS_CONTINUATION = json.load(f)
    except Exception as e:
        logger.error(f"Error loading chats continuation: {e}")
        CHATS_CONTINUATION = {}


def save_chats_continuation():
    try:
        with open(CHATS_CONTINUATION_FILE, 'w', encoding='utf-8') as f:
            json.dump(CHATS_CONTINUATION, f, ensure_ascii=False, indent=2)
    except Exception as e:
        logger.error(f"Error saving chats continuation: {e}")


import logging
import sys

# –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è –¥–ª—è –≤—ã–≤–æ–¥–∞ –≤ –∫–æ–Ω—Å–æ–ª—å (stdout)
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.StreamHandler(sys.stdout)
    ]
)
logger = logging.getLogger(__name__)

ADMIN_ID = int(os.environ.get("ADMIN_ID", "5855297931"))
# BOT_TOKEN should be set via environment variable for security
BOT_TOKEN = "8575852674:AAEcaG0l7cQ3JHSrs1MaBkA_wQPQYshpSs0"
bot = Bot(token=BOT_TOKEN)
dp = Dispatcher()
router = Router()


class AdminMenuStates(StatesGroup):
    main = State()
    managing_menu = State()
    adding_button_label = State()
    adding_button_content = State()
    adding_button_photo = State()
    adding_inline_button_text = State()
    adding_inline_button_url = State()
    confirming_button = State()
    creating_nested = State() # For deep nesting

class BroadcastStates(StatesGroup):
    waiting_for_text = State()
    waiting_for_photo = State()
    waiting_for_buttons_menu = State()
    waiting_for_button_name = State()
    waiting_for_button_url = State()
    confirm_broadcast = State()

class ButtonEditStates(StatesGroup):
    selecting_button = State()
    waiting_for_content = State()
    waiting_for_photo = State()
    waiting_for_inline_buttons = State()

# –ù–æ–≤–∞—è —Å–∏—Å—Ç–µ–º–∞ —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è –∫–æ–Ω—Ç–µ–Ω—Ç–∞
class ContentEditorStates(StatesGroup):
    selecting_menu = State()  # –í—ã–±–æ—Ä –º–µ–Ω—é –¥–ª—è —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è
    editing_text = State()     # –†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ —Ç–µ–∫—Å—Ç–∞
    editing_inline_buttons = State()  # –†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –∏–Ω–ª–∞–π–Ω-–∫–Ω–æ–ø–æ–∫
    adding_inline_button = State()    # –î–æ–±–∞–≤–ª–µ–Ω–∏–µ –Ω–æ–≤–æ–π –∏–Ω–ª–∞–π–Ω-–∫–Ω–æ–ø–∫–∏
    waiting_button_text = State()     # –û–∂–∏–¥–∞–Ω–∏–µ —Ç–µ–∫—Å—Ç–∞ –∫–Ω–æ–ø–∫–∏
    waiting_button_url = State()      # –û–∂–∏–¥–∞–Ω–∏–µ URL –∫–Ω–æ–ø–∫–∏
    managing_inline_buttons = State()  # –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –∏–Ω–ª–∞–π–Ω-–∫–Ω–æ–ø–∫–∞–º–∏ (—É–¥–∞–ª–µ–Ω–∏–µ, —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ)
    editing_inline_button_name = State()  # –†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –Ω–∞–∑–≤–∞–Ω–∏—è –∏–Ω–ª–∞–π–Ω-–∫–Ω–æ–ø–∫–∏
    editing_keyboard_button_name = State()  # –†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –Ω–∞–∑–≤–∞–Ω–∏—è –∫–Ω–æ–ø–∫–∏ –∫–ª–∞–≤–∏–∞—Ç—É—Ä—ã

class ChatsContinuationStates(StatesGroup):
    selecting_chat_section = State()
    managing_lines = State()
    editing_line = State()


# Fixed menu structure
MENU_STRUCTURE = {
    "garant_checker": {
        "label": "üõ° Garant Checker",
        "text":
        "üõ°<b>–ì–∞—Ä–∞–Ω—Ç ‚Äî —á–µ–ª–æ–≤–µ–∫, –∫–æ—Ç–æ—Ä—ã–π –æ–±–µ—Å–ø–µ—á–∏–≤–∞–µ—Ç –±–µ–∑–æ–ø–∞—Å–Ω—É—é —Å–¥–µ–ª–∫—É –ø–æ –∫—É–ø–ª–∏/–ø—Ä–æ–¥–∞–∂–µ –∫–∞–Ω–∞–ª–æ–≤/—á–∞—Ç–æ–≤/–±–æ—Ç–æ–≤ –∏ –≤ —Ü–µ–ª–æ–º –Ω–µ–º–∞—Ç–µ—Ä–∏–∞–ª—å–Ω—ã—Ö —Ç–æ–≤–∞—Ä–æ–≤ –≤ –∏–Ω—Ç–µ—Ä–Ω–µ—Ç–µ.</b>\n\n<b>‚úÖ–°–ø–∏—Å–æ–∫ –∏–∑–≤–µ—Å—Ç–Ω—ã—Ö –≥–∞—Ä–∞–Ω—Ç–æ–≤</b>\n\n@Qu3rs <code>[387852767]</code>\n@Reingardt_garant <code>[6530759749]</code>\n@hooligan154 <code>[497153130]</code>\n@ladesov <code>[305094295]</code>\n@bIackkro <code>[5426593798]</code>\n@el_capitano8 <code>[1255230337]</code>\n@khanv <code>[2123115047]</code>\n@aizek <code>[1955213939]</code>\n@M_Brightside <code>[1157640533]</code>\n\n<blockquote>‚ö†Ô∏è–ë—É–¥—å—Ç–µ –≤–Ω–∏–º–∞—Ç–µ–ª—å–Ω—ã, –º–æ–≥—É—Ç –æ—Ä—É–¥–æ–≤–∞—Ç—å —Ñ–µ–π–∫–∏ –∏ –º–æ—à–µ–Ω–Ω–∏–∫–∏. –°–æ–∑–¥–∞–π—Ç–µ –ø–µ—Ä–µ–ø–∏—Å–∫—É —Å –≥–∞—Ä–∞–Ω—Ç–æ–º + –¥–æ–±–∞–≤—å—Ç–µ –µ–≥–æ –≤ –≤–∞—à–∏ –∫–æ–Ω—Ç–∞–∫—Ç—ã —á—Ç–æ–±—ã –Ω–µ –ø–µ—Ä–µ–ø—É—Ç–∞—Ç—å.</blockquote>",
        "type": "inline",
        "submenu": {
            "info": {
                "label": "‚ÑπÔ∏è –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è",
                "text":
                "–£ –º–æ—à–µ–Ω–Ω–∏–∫–æ–≤ –¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –º–Ω–æ–≥–æ –≤—Å—è–∫–∏—Ö —Å—Ö–µ–º –∫–∞–∫ –º–æ–∂–Ω–æ –≤–∞—Å –æ–±–º–∞–Ω—É—Ç—å, –≤ –æ—Å–Ω–æ–≤–Ω–æ–º –æ–Ω–∏ —Å—Ç—Ä–æ—è—Ç—Å—è –Ω–∞ –≤–∞—à–µ–π –Ω–µ–≤–Ω–∏–º–∞—Ç–µ–ª—å–Ω–æ—Å—Ç–∏ –∏ –∂–∞–¥–Ω–æ—Å—Ç–∏.\n\n–° –ø–æ–º–æ—â—å—é –∫–Ω–æ–ø–æ–∫ –Ω–∏–∂–µ –≤—ã —Å–º–æ–∂–µ—Ç–µ –æ–∑–Ω–∞–∫–æ–º–∏—Ç—å—Å—è —Å –¥–≤—É–º—è –∏–∑ –Ω–∏—Ö. –ë–æ–Ω—É—Å–æ–º, —è –æ—Å—Ç–∞–≤–∏–ª –¥–ª—è –≤–∞—Å —Å–ø–∏—Å–æ–∫ –±–∏—Ä–∂-—Ç–µ–ª–µ–≥—Ä–∞–º –∫–∞–Ω–∞–ª–æ–≤, –≤ —Ç–æ–º —á–∏—Å–ª–µ –ø–æ–ø—É–ª—è—Ä–Ω—ã—Ö –≥–∞—Ä–∞–Ω—Ç–æ–≤",
                "type": "inline",
                "submenu": {
                    "exchanges": {
                        "label":
                        "üì∫ –ë–ò–†–ñ–ò –ö–ê–ù–ê–õ–û–í",
                        "text":
                        "<b>üì∫–ë–∏—Ä–∂–∏ –∫–∞–Ω–∞–ª–æ–≤ - —ç—Ç–æ —á–∞—Ç—ã/–∫–∞–Ω–∞–ª—ã –≤ –∫–æ—Ç–æ—Ä—ã—Ö –≤—ã –º–æ–∂–µ—Ç–µ –ø—Ä–æ–¥–∞—Ç—å/–∫—É–ø–∏—Ç—å —Ç–µ–ª–µ–≥—Ä–∞–º-–ø—Ä–æ–µ–∫—Ç—ã</b>\n\n–° –ø–æ–ª–Ω—ã–º —Å–ø–∏—Å–∫–æ–º –±–∏—Ä–∂ –º–æ–∂–Ω–æ –æ–∑–Ω–∞–∫–æ–º–∏—Ç—å—Å—è –ø–æ <a href=\"https://t.me/LBR_Chats/33\">—Å—Å—ã–ª–∫–µ</a>"
                    },
                    "mammontav1": {
                        "label":
                        "—Å—Ö–µ–º–∞ 1",
                        "text":
                        "<b>–ö–∞–∫ –Ω–µ —Å—Ç–∞—Ç—å –º–∞–º–æ–Ω—Ç–æ–º</b> [—á–∞—Å—Ç—å 1]\n\n1. –°—Ç–∞–¥–∏—è –ø–µ—Ä–µ–≥–æ–≤–æ—Ä–æ–≤\n–í—ã –ø—Ä–∏–Ω—è–ª–∏ —Ä–µ—à–µ–Ω–∏–µ —á—Ç–æ —Ö–æ—Ç–∏—Ç–µ –ø—Ä–æ–¥–∞—Ç—å —Å–≤–æ–π –∫–∞–Ω–∞–ª. –ù–∞—à–ª–∏ –ø–æ–∫—É–ø–∞—Ç–µ–ª—è –∏ –∏–¥—ë—Ç —Å—Ç–∞–¥–∏—è –ø–µ—Ä–µ–≥–æ–≤–æ—Ä–æ–≤: —Ç–æ—Ä–≥–∏ –ø–æ –∫–æ–Ω–µ—á–Ω–æ–π —Å—Ç–æ–∏–º–æ—Å—Ç–∏ –∫–∞–Ω–∞–ª–∞, —Å–ø–æ—Å–æ–± –æ–ø–ª–∞—Ç—ã –∏ –ø—Ä–æ—á–µ–µ.\n\n–ü–æ–∫—É–ø–∞—Ç–µ–ª—å –ø—Ä–µ–¥–ª–∞–≥–∞–µ—Ç –í–∞–º –≥–∞—Ä–∞–Ω—Ç–∞, –∫–æ—Ç–æ—Ä–æ–≥–æ –∑–Ω–∞–µ—Ç–µ –∏ –í—ã ‚Äî –≤—Å—ë –≤—Ä–æ–¥–µ —Ö–æ—Ä–æ—à–æ. –û–Ω –í–∞–º –∫–∏–Ω—É–ª –≤ –ª–∏—á–Ω–æ–π –ø–µ—Ä–µ–ø–∏—Å–∫–µ –ª–∏–Ω–∫ –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω–æ–≥–æ –≥–∞—Ä–∞–Ω—Ç–∞ ‚Äî –≥—É–¥, —Ä–∞–±–æ—Ç–∞–µ–º.\n\n2. –°—Ç–∞–¥–∏—è —Å–¥–µ–ª–∫–∏.\n–í—Å—ë —Ö–æ—Ä–æ—à–æ, –≥–∞—Ä–∞–Ω—Ç–∞ —Å–æ–≥–ª–∞—Å–æ–≤–∞–ª–∏, —Å—Ç–æ–∏–º–æ—Å—Ç—å –∏ –ø—Ä–æ—á–µ–µ —Ç–æ–∂–µ. –ò –≤–æ—Ç —Ç—É—Ç, –í–∞—Å –ø—Ä–∏–≥–ª–∞—à–∞—é—Ç –≤ —á–∞—Ç, –≥–¥–µ –±—É–¥–µ—Ç–µ —Ç–æ–ª—å–∫–æ –í—ã, –ø–æ–∫—É–ø–∞—Ç–µ–ª—å –∏ –≥–∞—Ä–∞–Ω—Ç.\n\n<b>‚ùóÔ∏è–ò —Ç—É—Ç –æ—á–µ–Ω—å –≤–∞–∂–Ω—ã–π –º–æ–º–µ–Ω—Ç</b>\n\n–ù–µ –Ω–∞—á–∏–Ω–∞–π—Ç–µ —Å–¥–µ–ª–∫—É, –ø–æ–∫–∞ –Ω–µ —É–±–µ–¥–∏—Ç–µ—Å—å –≤ —Å–ª–µ–¥—É—é—â–µ–º:\n\n–ù–∞ —Å—Ç–∞–¥–∏–∏, –∫–æ–≥–¥–∞ –≥–∞—Ä–∞–Ω—Ç –∑–∞—Ö–æ–¥–∏—Ç –≤ —á–∞—Ç, –∏–ª–∏ –æ–Ω —É–∂–µ –≤ –Ω—ë–º –µ—Å—Ç—å ‚Äî <b>–í–°–ï–ì–î–ê –ø—Ä–æ–≤–µ—Ä—è–π—Ç–µ –ø–æ–≤—Ç–æ—Ä–Ω–æ –≥–∞—Ä–∞–Ω—Ç–∞ –∫–æ—Ç–æ—Ä—ã–π —Å–∏–¥–∏—Ç –≤ —Å–∞–º–æ–º —á–∞—Ç–µ.</b>\n\n–ü–æ—Ç–æ–º—É —á—Ç–æ –í–∞–º –≤ –ª–∏—á–Ω–æ–π –ø–µ—Ä–µ–ø–∏—Å–∫–µ –º–æ–≥—É—Ç –ø—Ä–µ–¥–ª–æ–∂–∏—Ç—å –ª–∏–Ω–∫ –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω–æ–≥–æ –≥–∞—Ä–∞–Ω—Ç–∞, –∞ –≤ —Å–¥–µ–ª–∫—É –∑–∞–≤–µ—Å—Ç–∏ —Ñ–µ–π–∫–∞. –ò –Ω–µ–≤–Ω–∏–º–∞—Ç–µ–ª—å–Ω—ã–µ –ª—é–¥–∏ —Ç–∞–∫–∏–º —Å–ø–æ—Å–æ–±–æ–º —Ç–µ—Ä—è—é—Ç —Å–≤–æ–∏ –∫–∞–Ω–∞–ª—ã."
                    },
                    "mammontav2": {
                        "label":
                        "—Å—Ö–µ–º–∞ 2",
                        "text":
                        "<b>–ö–∞–∫ –Ω–µ —Å—Ç–∞—Ç—å –º–∞–º–æ–Ω—Ç–æ–º</b> [—á–∞—Å—Ç—å 2]\n\n–ß–µ–ª–æ–≤–µ–∫—É –Ω–∞–ø–∏—Å–∞–ª —Ñ–µ–π–∫-–∞–∫–∫–∞—É–Ω—Ç –æ–¥–Ω–æ–≥–æ –∞–¥–º–∏–Ω–∞ –∫—Ä—É–ø–Ω–æ–≥–æ –∫–∞–Ω–∞–ª–∞. –û–Ω –∫–∞–∫ —è –ø–æ–Ω–∏–º–∞—é –∑–Ω–∞–ª –≥–ª–∞–≤–Ω–æ–µ –ø—Ä–∞–≤–∏–ª–æ ‚Äî –≤—Å–µ–≥–¥–∞ —Å–º–æ—Ç—Ä–∏ –Ω–∞–ª–∏—á–∏–µ –∞–∫–∫–∞—É–Ω—Ç–∞ –≤ –æ–ø–∏—Å–∞–Ω–∏–∏ –∫–∞–Ω–∞–ª–∞, —á—Ç–æ–±—ã –Ω–µ –æ–±–º–∞–Ω—É–ª–∏.\n\n–û–Ω –∑–∞—à—ë–ª –Ω–∞ –∫–∞–Ω–∞–ª, –∫–∞–∫ –ø–æ–ª–∞–≥–∞–µ—Ç—Å—è, –ø–µ—Ä–µ—à—ë–ª –≤ –∞–∫–∫–∞—É–Ω—Ç, —É–±–µ–¥–∏–ª—Å—è –≤–∏–∑—É–∞–ª—å–Ω–æ –≤ –ø–æ–¥–ª–∏–Ω–Ω–æ—Å—Ç–∏ –∏ –≤—ã—à–µ–ª. –ù–æ –∑–∞–±—ã–ª –æ–¥–∏–Ω –æ—á–µ–Ω—å –≤–∞–∂–Ω—ã–π –Ω—é–∞–Ω—Å:\n\n<b>‚ùóÔ∏è–û–±—Ä–∞—â–∞–µ–º –≤–Ω–∏–º–∞–Ω–∏–µ –Ω–∞ —Å–ª–µ–¥—É—é—â–∏–π –º–æ–º–µ–Ω—Ç:</b>\n\n<code>l</code> - –º–∞–ª–µ–Ω—å–∫–∞—è, –∞–Ω–≥–ª–∏–π—Å–∫–∞—è –±—É–∫–≤–∞ \"–ª\"\n<code>I</code> - –∑–∞–≥–ª–∞–≤–Ω–∞—è, –∞–Ω–≥–ª–∏–π—Å–∫–∞—è –±—É–∫–≤–∞ \"–∏\"\n\n–û—á–µ–Ω—å —á–∞—Å—Ç–æ, –º–æ—à–µ–Ω–Ω–∏–∫–∏ –ø–æ–¥–¥–µ–ª—ã–≤–∞—é—Ç –∞–∫–∫–∞—É–Ω—Ç—ã —Ç–∞–∫–∏–º –æ–±—Ä–∞–∑–æ–º, –º–µ–Ω—è—è –≤—Å–µ–≥–æ –æ–¥–Ω—É –±—É–∫–≤—É.\n\n–ß–µ–ª–æ–≤–µ–∫ –ø—Ä–æ–≤—ë–ª –≤–∏–∑—É–∞–ª—å–Ω—ã–π –æ—Å–º–æ—Ç—Ä –∏ –ø–æ–Ω—è–ª, —á—Ç–æ –∞–∫–∫–∞—É–Ω—Ç—ã —è–≤–ª—è—é—Ç—Å—è –∏–¥–µ–Ω—Ç–∏—á–Ω—ã–º–∏, –ø–æ —Ñ–∞–∫—Ç—É —Å–º–æ—Ç—Ä—è —Ä–∞–∑–Ω—ã–µ –∞–∫–∫–∞—É–Ω—Ç—ã, –∏—Ç–æ–≥ ‚Äî —Å–∫–∞–º, –¥–µ–Ω—å–≥–∏ –æ—Ç–ø—Ä–∞–≤–∏–ª, —Ä–µ–∫–ª–∞–º–∞ –Ω–µ –≤—ã—à–ª–∞.\n\n<b>‚ùóÔ∏è–ö–∞–∫ —ç—Ç–æ–≥–æ –∏–∑–±–µ–∂–∞—Ç—å?</b>\n\n‚Äî –í–∞–º –Ω–∞–ø–∏—Å–∞–ª —á–µ–ª–æ–≤–µ–∫ —Å –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ–º —Ä–µ–∫–ª–∞–º—ã\n1. –û—Å–º–æ—Ç—Ä–∏—Ç–µ –∞–∫–∫–∞—É–Ω—Ç –≤–∏–∑—É–∞–ª—å–Ω–æ: —Ñ–æ—Ç–æ–≥—Ä–∞—Ñ–∏—é, –ø–æ–ª–µ –æ —Å–µ–±–µ –∏ –∏–º—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è.\n2. –ü–µ—Ä–µ—Ö–æ–¥–∏–º –≤ –∫–∞–Ω–∞–ª –≥–¥–µ –Ω–∞–º –ø—Ä–µ–¥–ª–∞–≥–∞—é—Ç –∫—É–ø–∏—Ç—å —Ä–µ–∫–ª–∞–º—É, –¥–∞–ª–µ–µ –ø–µ—Ä–µ—Ö–æ–¥–∏–º –≤ –æ–ø–∏—Å–∞–Ω–∏–µ.\n3. –ò—â–µ–º —Ç–∞–∫–æ–π-–∂–µ —é–∑–µ—Ä (–∏–º—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è) –∏ –Ω–∞–∂–∏–º–∞–µ–º, —á—Ç–æ–±—ã –ø–æ—Å–º–æ—Ç—Ä–µ—Ç—å –≤–æ–æ–±—â–µ –Ω–∞ –∞–∫–∫–∞—É–Ω—Ç.\n4. –£–±–µ–¥–∏–ª–∏—Å—å —á—Ç–æ –≤—Å—ë –∏–¥–µ–Ω—Ç–∏—á–Ω–æ –∏ –ø–æ—Å–ª–µ —ç—Ç–æ–≥–æ, <b>—á–∏—Ç–∞–µ–º –≤–Ω–∏–º–∞—Ç–µ–ª—å–Ω–æ:</b> –ü–µ—Ä–µ—Ö–æ–¥–∏–º –≤ –¥–∏–∞–ª–æ–≥ —Å –∞–∫–∫–∞—É–Ω—Ç–æ–º –∏–∑ –æ–ø–∏—Å–∞–Ω–∏—è –∫–∞–Ω–∞–ª–∞. –ù–µ –Ω—É–∂–Ω–æ –≤—ã—Ö–æ–¥–∏—Ç—å –∏–∑ –∞–∫–∫–∞—É–Ω—Ç–∞ –∏ –ø–µ—Ä–µ—Ö–æ–¥–∏—Ç—å –æ–±—Ä–∞—Ç–Ω–æ –≤ –¥–∏–∞–ª–æ–≥ —Å —Ç–µ–º –∫—Ç–æ –í–∞–º –Ω–∞–ø–∏—Å–∞–ª.\n\n–û—à–∏–±–∫–∞ —á–µ–ª–æ–≤–µ–∫–∞ –∏–∑ –Ω–∞—à–µ–π –∏—Å—Ç–æ—Ä–∏–∏ –≤ —Ç–æ–º, —á—Ç–æ –æ–Ω –ø—Ä–æ–≤–µ—Ä–∏–ª –∞–∫–∫–∞—É–Ω—Ç –≤–∏–∑—É–∞–ª—å–Ω–æ –∏ –≤—ã—à–µ–ª –∏–∑ –Ω–µ–≥–æ, –ø–µ—Ä–µ–π–¥—è –≤ –¥–∏–∞–ª–æ–≥ —Å —Ç–µ–º –∫—Ç–æ –Ω–∞–ø–∏—Å–∞–ª —Å –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ–º.\n\n–ê –ø–æ —Ñ–∞–∫—Ç—É, —ç—Ç–æ –±—ã–ª–∏ —Ä–∞–∑–Ω—ã–µ –∞–∫–∫–∞—É–Ω—Ç—ã, –≥–¥–µ –±—ã–ª–∞ –ø–æ–¥–º–µ–Ω–µ–Ω–∞ –≤—Å–µ–≥–æ –æ–¥–Ω–∞ –±—É–∫–≤–∞"
                    }
                }
            }
        }
    },
    "terminology": {
        "label":
        "üìñ –£—Ä–æ–∫ –¢–µ—Ä–º–∏–Ω–æ–ª–æ–≥–∏–∏",
        "pages": [{
            "text":
            "<b>–£—Ä–æ–∫ –¢–µ—Ä–º–∏–Ω–æ–ª–æ–≥–∏–∏ - —Å–ø–∏—Å–æ–∫ —Ç–µ—Ä–º–∏–Ω–æ–≤ –∏ –∞–±–±—Ä–µ–≤–∏–∞—Ç—É—Ä, –∫–æ—Ç–æ—Ä—ã–µ –∞–¥–º–∏–Ω—ã –∏ –Ω–µ —Ç–æ–ª—å–∫–æ –∏—Å–ø–æ–ª—å–∑—É—é—Ç –≤ –ø–æ–≤—Å–µ–¥–Ω–µ–≤–Ω–æ–π —Ç–µ–ª–µ–≥—Ä–∞–º–æ–≤—Å–∫–æ–π –∂–∏–∑–Ω–∏.</b>\n\n<b>–°–ø–∏—Å–æ–∫ —Ç–µ—Ä–º–∏–Ω–æ–≤/–∞–±–±—Ä–µ–≤–∏–∞—Ç—É—Ä</b>\n\n‚Ä¢ <b>–ü–°–ò–•–û</b> - –ø—Å–∏—Ö–æ–ª–æ–≥–∏—è [—Ç–µ–º–∞—Ç–∏–∫–∞]\n‚Ä¢ <b>–°–ú</b> - —Å–∞–º–æ—Ä–∞–∑–≤–∏—Ç–∏–µ [—Ç–µ–º–∞—Ç–∏–∫–∞]\n‚Ä¢ <b>–¶–ê</b> - —Ü–µ–ª–µ–≤–∞—è –∞—É–¥–∏—Ç–æ—Ä–∏—è\n‚Ä¢ <b>–ñ–¶–ê</b> - –∂–µ–Ω—Å–∫–∞—è —Ü–µ–ª–µ–≤–∞—è –∞—É–¥–∏—Ç–æ—Ä–∏—è\n‚Ä¢ <b>–ú–¶–ê</b> - –º—É–∂—Å–∫–∞—è —Ü–µ–ª–µ–≤–∞—è –∞—É–¥–∏—Ç–æ—Ä–∏—è\n‚Ä¢ <b>–°–¶–ê</b> - —Å–º–µ—à–∞–Ω–Ω–∞—è –¶–ê\n‚Ä¢ <b>–ü–î–ü</b> - –ø–æ–¥–ø–∏—Å—á–∏–∫-(–∏)\n‚Ä¢ <b>–ê–£–î–ò–¢</b> - –∞—É–¥–∏—Ç–æ—Ä–∏—è –∫–∞–Ω–∞–ª–∞/–±–æ—Ç–∞ –∏ —Ç–∞–∫ –¥–∞–ª–µ–µ\n‚Ä¢ <b>–õ–ò–ù–ö</b> - —Å—Å—ã–ª–∫–∞ –Ω–∞ –∫–∞–Ω–∞–ª/–ø—Ä–æ—Ñ–∏–ª—å\n‚Ä¢ <b>–û–¢–ö–†–´–¢–ê–Ø –°–°–´–õ–ö–ê</b> - –æ–Ω–∞ –∂–µ –ª–∏–Ω–∫, —Å—Å—ã–ª–∫–∞ –Ω–∞ –∫–∞–Ω–∞–ª –±–µ–∑ –∑–∞—è–≤–∫–∏ –Ω–∞ –≤—Å—Ç—É–ø–ª–µ–Ω–∏—è\n‚Ä¢ <b>–°–†–ú/–¶–ü–ú/–°–ü–ú</b> - —Ü–µ–Ω–∞ –∑–∞ 1.000 –ø—Ä–æ—Å–º–æ—Ç—Ä–æ–≤, —É –∫–∞–∂–¥–æ–π —Ç–µ–º–∞—Ç–∏–∫–∏ —Å–≤–æ—è —Ü–µ–Ω–∞.\n‚Ä¢ <b>–õ–°</b> - –ª–∏—á–Ω—ã–µ —Å–æ–æ–±—â–µ–Ω–∏—è."
        }, {
            "text":
            "<b>–°–ø–∏—Å–æ–∫ —Ç–µ—Ä–º–∏–Ω–æ–≤/–∞–±–±—Ä–µ–≤–∏–∞—Ç—É—Ä</b>\n\n‚Ä¢ <b>–û–•–í–ê–¢–´ (–ì–õ–ê–ó–ê)</b> - –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø—Ä–æ—Å–º–æ—Ç—Ä–æ–≤ –Ω–∞ –ø–æ—Å—Ç–µ. –ú–æ–∂–Ω–æ –ø–æ—Å–º–æ—Ç—Ä–µ—Ç—å –≤ –ø—Ä–∞–≤–æ–º –Ω–∏–∂–µ–º —É–≥–ª—É –≤ –∫–∞–Ω–∞–ª–µ.\n‚Ä¢ <b>–°–¢–ê–¢–ê</b> - —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞.\n‚Ä¢ <b>–°–¢–ê–¢–ê +++</b> - –ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω—ã–π –ø—Ä–∏—Ä–æ—Å—Ç –ø–æ–¥–ø–∏—Å—á–∏–∫–æ–≤ –∑–∞ –¥–µ–Ω—å/–Ω–µ–¥–µ–ª—é/–º–µ—Å—è—Ü\n‚Ä¢ <b>–¢–ú</b> - —Å–µ—Ä–≤–∏—Å –∞–Ω–∞–ª–∏—Ç–∏–∫–∏ Telemetr\n‚Ä¢ <b>–¢–ì–°–¢–ê–¢</b> - —Å–µ—Ä–≤–∏—Å –∞–Ω–∞–ª–∏—Ç–∏–∫–∏ TGStat\n‚Ä¢ <b>–ì–ê–†–¨</b> - –º–µ—Å—Ç–æ –∫–æ—Ç–æ—Ä–æ–µ —Å—Ä–æ—á–Ω–æ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ –∑–∞–∫—Ä—ã—Ç—å —Ä–µ–∫–ª–∞–º–Ω—ã–º –ø–æ—Å—Ç–æ–º, –æ–±—ã—á–Ω–æ –ø—Ä–æ–¥–∞—é—Ç —Å –∫–∞–∫–æ–π-–ª–∏–±–æ –ø–ª—é—à–∫–æ–π (–¥–æ–ø.–ª–µ–Ω—Ç–∞ –∏–ª–∏ —Å–∫–∏–¥–∫–∞).\n‚Ä¢ <b>–¢–ì –¢–†–ê–§</b> - —Ç–∏–ø —Ç—Ä–∞—Ñ–∏–∫–∞, –∫–∞–Ω–∞–ª –∫–æ—Ç–æ—Ä—ã–π –ø–æ–ª—É—á–∞–µ—Ç –∞—É–¥–∏—Ç–æ—Ä–∏—é –∏–º–µ–Ω–Ω–æ —Å –¢–µ–ª–µ–≥—Ä–∞–º–∞, –ø—É—Ç–µ–º –ø—Ä–∏–æ–±—Ä–µ—Ç–µ–Ω–∏—è —Ä–µ–∫–ª–∞–º—ã –≤ —Å–º–µ–∂–Ω—ã—Ö –¢–ì –∫–∞–Ω–∞–ª–∞—Ö, –ª–∏–±–æ –≤ –±–æ—Ç–∞—Ö (—Ä–∞—Å—Å—ã–ª–∫–∞, –ø—Ä–∏–≤–µ—Ç—Å–≤–∏–µ)."
        }, {
            "text":
            "<b>–°–ø–∏—Å–æ–∫ —Ç–µ—Ä–º–∏–Ω–æ–≤/–∞–±–±—Ä–µ–≤–∏–∞—Ç—É—Ä</b>\n\n‚Ä¢ <b>1/24</b> - 1 —á–∞—Å —Ç–æ–ø–∞ –∏ 24 –ª–µ–Ω—Ç—ã (–º–æ–∂–µ—Ç –≤–∞—Ä—å–∏—Ä–æ–≤–∞—Ç—å—Å—è)\n‚Ä¢ <b>–¢–û–ü</b> - –≤—Ä–µ–º—è, –∫–æ—Ç–æ—Ä–æ–µ —Ä–µ–∫–ª–∞–º–∞ –≤–∏—Å–∏—Ç –ø–æ—Å–ª–µ–¥–Ω–∏–º –ø–æ—Å—Ç–æ–º\n‚Ä¢ <b>–õ–ï–ù–¢–ê</b> - –≤—Ä–µ–º—è —á–µ—Ä–µ–∑ –∫–æ—Ç–æ—Ä–æ–µ —É–¥–∞–ª—è–µ—Ç—Å—è —Ä–µ–∫–ª–∞–º–∞\n‚Ä¢ <b>–ü–†–Ø–ú–û–ô –ü–û–°–¢</b> - —Ä–µ–∫–ª–∞–º–Ω—ã–π –ø–æ—Å—Ç, –æ–ø–∏—Å—ã–≤–∞—é—â–∏–π –∫–æ–Ω—Ç–µ–Ω—Ç –∫–∞–Ω–∞–ª–∞\n‚Ä¢ <b>–ö–õ–ò–ö–ë–ï–ô–¢(–ö–õ–ò–ö)</b> - –ø–æ—Å—Ç, –∑–∞–≤–ª–µ–∫–∞—é—â–∏–π —á–µ–ª–æ–≤–µ–∫–∞ –≤ –∫–∞–Ω–∞–ª –ø—É—Ç—ë–º –æ–ø—Ä–æ—Å–∞, —Ä–∞—Å—Å–∫–∞–∑–∞ –∏—Å—Ç–æ—Ä–∏–∏ –∏ —Ä–µ–∑–∫–æ–≥–æ –µ—ë –æ–±—Ä—ã–≤–∞ (–ø–æ—Å—Ç-–ø—Ä–æ–¥–æ–ª–∂–µ–Ω–∏–µ)\n‚Ä¢ <b>–ü–†–û–ö–õ–ê–î–ö–ê/–ü–ï–†–ï–•–û–î–ù–ò–ö</b> - –ø—É–±–ª–∏—á–Ω—ã–π –∫–∞–Ω–∞–ª, –≤ –∫–æ—Ç–æ—Ä–æ–º –≤—ã–ª–æ–∂–µ–Ω–∞ –ø—Ä–∏–≤–∞—Ç–Ω–∞—è —Å—Å—ã–ª–∫–∞\n‚Ä¢ <b>–û–¢–õ–û–ñ–ö–ê/–û–¢–õ–û–ì–ê</b> -  –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∞—è –ø—É–±–ª–∏–∫–∞—Ü–∏—è –ø–æ—Å—Ç–∞ –≤ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–Ω–æ–µ –≤—Ä–µ–º—è –∏ –¥–∞—Ç—É\n‚Ä¢ <b>–°–ü–ê–ú</b> -  –≤–∏–¥ –Ω–∞–∫–∞–∑–∞–Ω–∏—è –∏–∑-–∑–∞ –∂–∞–ª–æ–± –Ω–∞ –≤–∞—Å, –∫–æ—Ç–æ—Ä—ã–π –∑–∞–ø—Ä–µ—â–∞–µ—Ç –≤–∞–º –ø–∏—Å–∞—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è–º, –∫–æ—Ç–æ—Ä—ã—Ö –Ω–µ—Ç —É –≤–∞—Å –≤ –∫–æ–Ω—Ç–∞–∫—Ç–∞—Ö. –ï—â—ë —ç—Ç–æ –æ–∑–Ω–∞—á–∞–µ—Ç —Ä–∞—Å—Å—ã–ª–∫—É –≤ –ª–∏—á–Ω—ã–µ —Å–æ–æ–±—â–µ–Ω–∏—è –≤—Å—è–∫–æ–π —Ä–µ–∫–ª–∞–º—ã –∏ –ø—Ä–æ—á–µ–≥–æ."
        }, {
            "text":
            "<b>–°–ø–∏—Å–æ–∫ —Ç–µ—Ä–º–∏–Ω–æ–≤/–∞–±–±—Ä–µ–≤–∏–∞—Ç—É—Ä</b>\n\n‚Ä¢ <b>–î–ï–ú–ü–ò–ù–ì</b> - –∑–∞–Ω–∏–∂–µ–Ω–∏–µ —Ü–µ–Ω—ã –Ω–∞ —Ä–µ–∫–ª–∞–º—É —Å–∏–ª—å–Ω–æ –Ω–∏–∂–µ —Ä—ã–Ω–∫–∞.\n‚Ä¢ <b>–ì–ê–†–ê–ù–¢</b> -  –ø–æ—Å—Ä–µ–¥–Ω–∏–∫ –≤ —Å–¥–µ–ª–∫–µ –ø–æ –ø–æ–∫—É–ø–∫–µ/–ø—Ä–æ–¥–∞–∂–∏ –∫–∞–Ω–∞–ª–∞, –∫–æ—Ç–æ—Ä—ã–π –¥–∞–µ—Ç –≥–∞—Ä–∞–Ω—Ç–∏—é –Ω–∞ —Ç–æ, —á—Ç–æ –Ω–∏–∫—Ç–æ –Ω–∏–∫–æ–≥–æ –Ω–µ –æ–±–º–∞–Ω–µ—Ç\n‚Ä¢ <b>–ì–ê–†–ê–ù–¢ –ü–î–ü</b> - —Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω–∞—è —Ü–µ–Ω–∞ –∑–∞ –ø–æ–¥–ø–∏—Å—á–∏–∫–∞ —Å –∫—É–ø–ª–µ–Ω–Ω–æ–π —Ä–µ–∫–ª–∞–º—ã. –ù–∞–ø—Ä–∏–º–µ—Ä: –≤—ã –∫—É–ø–∏–ª–∏ —Ä–µ–∫–ª–∞–º—É –∑–∞ 1000‚ÇΩ —Å –≥–∞—Ä–∞–Ω—Ç–æ–º –≤ 10‚ÇΩ, –∑–Ω–∞—á–∏—Ç –≤–∞–º –¥–æ–ª–∂–Ω–æ –ø—Ä–∏–π—Ç–∏ 100 –ø–æ–¥–ø–∏—Å—á–∏–∫–æ–≤ —Å —ç—Ç–æ–π —Ä–µ–∫–ª–∞–º—ã, –∏–Ω–∞—á–µ –≤–∞–º –æ–±—è–∑–∞–Ω—É –±—É–¥—É—Ç –¥–æ–≤–µ—Å—Ç–∏ –æ—Ç–¥–∞—á—É –¥–æ 100 –ø–¥–ø –∏–ª–∏ –≤–µ—Ä–Ω—É—Ç—å —Ä–∞–∑–Ω–∏—Ü—É\n‚Ä¢ <b>–ì–ï–û</b> -  —Å—Ç—Ä–∞–Ω–∞ –Ω–∞—Ö–æ–∂–¥–µ–Ω–∏—è –∞—É–¥–∏—Ç–æ—Ä–∏–∏ –∫–∞–Ω–∞–ª–∞. –£ –Ω–µ–∫–æ—Ç–æ—Ä—ã—Ö –∫–∞–Ω–∞–ª–æ–≤ –≥–µ–æ –ø–∏—à–µ—Ç—Å—è –Ω–∞ –¢–µ–ª–µ–º–µ—Ç—Ä–µ. –ì–µ–æ –≤—Å–µ–≥–¥–∞ –º–æ–∂–Ω–æ –ø–æ—Å–º–æ—Ç—Ä–µ—Ç—å –≤–æ –≤–Ω—É—Ç—Ä–µ–Ω–Ω–µ–π —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–µ –∫–∞–Ω–∞–ª–∞, –Ω–æ –¥–æ—Å—Ç—É–ø–Ω–∞ –æ–Ω–∞ —Ç–æ–ª—å–∫–æ –∞–¥–º–∏–Ω—É\n‚Ä¢ <b>–ü–û–î–ë–û–†–ö–ê</b> - —Å–ø–∏—Å–æ–∫ –∏–∑ 3-8 –∫–∞–Ω–∞–ª–æ–≤ –ø–æ —Å—Ö–æ–∂–µ–π —Ç–µ–º–∞—Ç–∏–∫–µ\n‚Ä¢ <b>–ú–ï–ì–ê</b> -  –ö—Ä—É–ø–Ω–∞—è –ø–æ–¥–±–æ—Ä–∫–∞ –∫–∞–Ω–∞–ª–æ–≤ —Ä–∞–∑–Ω–æ–π —Ç–µ–º–∞—Ç–∏–∫–∏"
        }, {
            "text":
            "<b>–°–ø–∏—Å–æ–∫ —Ç–µ—Ä–º–∏–Ω–æ–≤/–∞–±–±—Ä–µ–≤–∏–∞—Ç—É—Ä</b>\n\n‚Ä¢ <b>–û–ü</b> - –æ–±—è–∑–∞—Ç–µ–ª—å–Ω–∞—è –ø–æ–¥–ø–∏—Å–∫–∞, –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –∫–∞–∫ –ø—Ä–∞–≤–∏–ª–æ –≤ –±–æ—Ç–∞—Ö (—á—Ç–æ–±—ã –ø–æ–ª—å–∑–æ–≤–∞—Ç—å—Å—è –±–æ—Ç–æ–º –Ω—É–∂–Ω–æ –ø–æ–¥–ø–∏—Å–∞—Ç—å—Å—è –Ω–∞ –ù–ù–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –∫–∞–Ω–∞–ª–æ–≤.\n‚Ä¢ <b>–ö–†–ï–ê–¢–ò–í/–ö–†–ï–û</b> -  —Ä–µ–∫–ª–∞–º–Ω—ã–π –ø–æ—Å—Ç\n‚Ä¢ <b>–û–¢–í–ï–¢–ö–ê</b> -  –æ—Ç–≤–µ—Ç –Ω–∞ —Ä–µ–∫–ª–∞–º–Ω—ã–π –ø–æ—Å—Ç —Ñ—Ä–∞–∑–æ–π –∏/–∏–ª–∏ —Å—Å—ã–ª–∫–æ–π –Ω–∞ —Ä–µ–∫–ª–∞–º–∏—Ä—É–µ–º—ã–π –∫–∞–Ω–∞–ª\n‚Ä¢ <b>–í–ü</b> -  –≤–∑–∞–∏–º–Ω—ã–π –ø–∏–∞—Ä, –∞–¥–º–∏–Ω—ã —Ä–µ–∫–ª–∞–º–∏—Ä—É—é—Ç –∫–∞–Ω–∞–ª—ã –¥—Ä—É–≥ –¥—Ä—É–≥–∞ (—É–ø–æ—Ç—Ä–µ–±–ª–µ–Ω–∏–µ: \"–î–∞–≤–∞–π –í–ü –ø–æ—Å—Ç–∞–≤–∏–º\")\n‚Ä¢ <b>–†–ï–ò–ù–í–ï–°–¢</b> - –≤–ª–æ–∂–µ–Ω–∏–µ —á–∞—Å—Ç–∏ —Å—Ä–µ–¥—Å—Ç–≤ —Å –ø—Ä–∏–±—ã–ª–∏ –æ–±—Ä–∞—Ç–Ω–æ –≤ –∫–∞–Ω–∞–ª (—Ä–µ–∏–Ω–≤–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ)."
        }, {
            "text":
            "<b>–°–ø–∏—Å–æ–∫ —Ç–µ—Ä–º–∏–Ω–æ–≤/–∞–±–±—Ä–µ–≤–∏–∞—Ç—É—Ä</b>\n\n‚Ä¢ <b>–§–£–õ–õ –†–ï–ò–ù–í–ï–°–¢, –§–£–õ–õ</b> - –ø–æ–ª–Ω–æ–µ (100%) —Ä–µ–∏–Ω–≤–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ —Å—Ä–µ–¥—Å—Ç–≤ –≤ –∑–∞–∫—É–ø–∫—É —Ä–µ–∫–ª–∞–º—ã –Ω–∞ –∫–∞–Ω–∞–ª\n(—É–ø–æ—Ç—Ä–µ–±–ª–µ–Ω–∏–µ: \"–†–∞—Å—Å–º–æ—Ç—Ä—é —Ç–æ–ª—å–∫–æ –∫–∞–Ω–∞–ª—ã –Ω–∞ —Ñ—É–ª–ª —Ä–µ–∏–Ω–≤–µ—Å—Ç–µ\", \"–ö—É–ø–ª—é –ø–æ–¥ —Ñ—É–ª–ª\" (–ø–æ–¥—Ä–∞–∑—É–º–µ–≤–∞–µ—Ç—Å—è —Ñ—É–ª–ª —Ä–µ–∏–Ω–≤–µ—Å—Ç)\n‚Ä¢ <b>–†–ï–ò–ù–í–ï–°–¢ –§–£–õ–õ+, –§–£–õ–õ+</b> - —Ä–µ–∏–Ω–≤–µ—Å—Ç–∏—Ä—É–µ—Ç—Å—è –ë–û–õ–¨–®–ï 100% —Å—Ä–µ–¥—Å—Ç–≤, –∑–∞—Ä–∞–±–æ—Ç–Ω–Ω—ã—Ö –∫–∞–Ω–∞–ª–æ–º —Å –ø—Ä–æ–¥–∞–∂–∏ —Ä–µ–∫–ª–∞–º—ã\n(—É–ø–æ—Ç—Ä–µ–±–ª–µ–Ω–∏–µ: \"–ö—É–ø–ª—é —Ä–µ–∫–ª–∞–º—É —Ñ—É–ª–ª+\")\n‚Ä¢ <b>–£–ë–¢</b> - —É—Å–ª–æ–≤–Ω–æ –±–µ—Å–ø–ª–∞—Ç–Ω—ã–π —Ç—Ä–∞—Ñ–∏–∫. –í–∏–¥ —Ç—Ä–∞—Ñ–∏–∫–∞, –∫–æ—Ç–æ—Ä—ã–π –ø–µ—Ä–µ–≥–æ–Ω—è–µ—Ç—Å—è —Å –¥—Ä—É–≥–∏—Ö –ø–ª–æ—â–∞–¥–æ–∫ –≤ —Ç–µ–ª–µ–≥—Ä–∞–º: —é—Ç—É–±, –∏–Ω—Å—Ç, —Ç–∏–∫-—Ç–æ–∫\n\n<b>–≠—Ç–æ –∫–æ–Ω–µ—Ü. –Ω–∞–¥–µ—é—Å—å —É –º–µ–Ω—è –ø–æ–ª—É—á–∏–ª–æ—Å—å –≤–Ω–µ—Å—Ç–∏ —è—Å–Ω–æ—Å—Ç–∏, —Å–ø–∞—Å–∏–±–æ —Ç–µ–±–µ –∑–∞ –ø—Ä–æ—á—Ç–µ–Ω–∏–µ ü§ù</b>"
        }]
    },
    "cpm_pdp": {
        "label": "üíµ –°–ü–ú –∏ –ü–î–ü",
        "text": "<b>–ß—Ç–æ –≤–∞—Å –∏–Ω—Ç–µ—Ä–µ—Å—É–µ—Ç?</b>",
        "type": "inline",
        "submenu": {
            "cpm_prices": {
                "label": "–¶–µ–Ω–∞ –°–ü–ú",
                "text":
                "–û–±–Ω–æ–≤–ª–µ–Ω–æ: 22.12.2025\n\n<b>–í—ã–±–µ—Ä–∏—Ç–µ —Ü–µ–Ω–æ–≤–æ–π –¥–∏–∞–ø–∞–∑–æ–Ω</b>",
                "type": "inline",
                "buttons": [{
                    "text": "üîô –ù–∞–∑–∞–¥",
                    "callback": "back_inline:cpm_pdp"
                }],
                "submenu": {
                    "cpm_range_1": {
                        "label":
                        "–î–æ 400–°–ü–ú",
                        "text":
                        "<b>–î–û 400–°–ü–ú</b>\n\n- –î–æ–º/–¥–∞—á–∞: 250-400\n- –í—è–∑–∞–Ω–∏–µ/–†—É–∫–æ–¥–µ–ª–∏–µ: 300-450\n- –Æ–º–æ—Ä: 300-500\n- –ü–æ–∑–Ω–∞–≤–∞–ª–∫–∞ –ò—Å—Ç–æ—Ä–∏—è [–±–∞–π—Ç]: 300-350\n- –ö—É–ª–∏–Ω–∞—Ä–∏—è: 300-400\n- –ì–æ—Ä–æ—Å–∫–æ–ø—ã: 350-550\n- –û—Ç–∫—Ä—ã—Ç–∫–∏: 300-350\n- WB –º–æ–ª–æ–¥–∞—è: 250-350\n- –ü–æ–ª–∏—Ç.–ù–æ–≤–æ—Å—Ç–∏: 250-350\n- –ù–æ–≤–æ—Å—Ç–∏ [–ø—Ä—è–º–æ–π]: 250-350+\n- –ù–æ–≤–æ—Å—Ç–∏ [–±–∞–π—Ç]: 200-300+\n- –¢—Ä–µ—à [–±–∞–π—Ç/–∑–∞—è–≤–∫–∞]: 200-350\n- –¢—Ä–µ—à [–±–∞–π—Ç/–∞–≤—Ç–æ–ø—Ä–∏—ë–º]: 200-350\n- –¢—Ä–µ—à [–ø—Ä—è–º–æ–π/–∑–∞—è–≤–∫–∞]: 200-350\n- –¢—Ä–µ—à [–ø—Ä—è–º–æ–π/–∞–≤—Ç–æ–ø—Ä–∏—ë–º]: 200-350\n- –í–æ–µ–Ω–∫–∞ [–±–∞–π—Ç]: 200-300\n- –ñ–∏–≤–æ—Ç–Ω—ã–µ: 350-400\n- –õ–∞–π—Ñ—Ö–∞–∫–∏: 300-400\n- –≠—Ä–æ/–ü—Ä–æ–Ω [–∑–∞—è–≤–∫–∞]: 100-250\n- –≠—Ä–æ/–ü—Ä–æ–Ω [–∞–≤—Ç–æ–ø—Ä–∏—ë–º]: 100-250\n\n<b>‚ùóÔ∏è–ó–∞–º–µ—Ç–∏–ª–∏ –æ—à–∏–±–∫—É/–Ω–µ—Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏–µ, –ø–æ–∂–∞–ª—É–π—Å—Ç–∞, <a href=\"https://t.me/Lambarin\">–Ω–∞–ø–∏—à–∏—Ç–µ –º–Ω–µ</a> –≤ –ª–∏—á–Ω—ã–µ —Å–æ–æ–±—â–µ–Ω–∏—è</b>",
                        "buttons": [{
                            "text": "üîô –ù–∞–∑–∞–¥",
                            "callback": "back_inline:cpm_prices"
                        }]
                    },
                    "cpm_range_2": {
                        "label":
                        "–û—Ç 400–°–ü–ú",
                        "text":
                        "<b>–û–¢ 400–°–ü–ú</b>\n\n- –ü–æ—Å–æ–±–∏—è [–ø—Ä—è–º–æ–π]: 500-700\n- –ü–æ—Å–æ–±–∏—è [–±–∞–π—Ç]: 500-700\n- –°—Ç—Ä–æ–∏—Ç–µ–ª—å—Å—Ç–≤–æ: 500-1000\n- –°–∞–º–æ—Ä–∞–∑–≤–∏—Ç–∏–µ/–ü—Å–∏—Ö–æ–ª–æ–≥–∏—è –ú–¶–ê: 700-1000\n- –ü–æ–∑–Ω–∞–≤–∞–ª–∫–∞ –ò—Å—Ç–æ—Ä–∏—è [–ø—Ä—è–º–æ–π]: 400-500\n- –ü–ü/–§–∏—Ç–Ω–µ—Å: 400-600\n- –ú–∞–º–æ—á–∫–∏: 600-900\n- –ó–¥–æ—Ä–æ–≤—å–µ: 600-1000\n- –î–∏–∑–∞–π–Ω –∏–Ω—Ç–µ—Ä—å–µ—Ä–∞: 700-900\n- –ê–≤—Ç–æ/–î–¢–ü: 500-700\n- –¶–∏—Ç–∞—Ç—ã: 500-600\n- –õ–∏—Ç–µ—Ä–∞—Ç—É—Ä–∞/–¶–∏—Ç–∞—Ç—ã: 600-1000\n- –î–æ–±—Ä—ã–µ –∫–∞–Ω–∞–ª—ã: 600-700\n- –ò—Å–∫—É—Å—Å—Ç–≤–æ: 600-800\n- –õ–∏–Ω–≥–≤–∏—Å—Ç–∏–∫–∞: 600-900\n- –ö–∏–Ω–æ: 400-500\n- –≠–∑–æ—Ç–µ—Ä–∏–∫–∞: 400-600\n- –ë—å—é—Ç–∏ –º–æ–ª–æ–¥–∞—è: 500-600\n\n<b>‚ùóÔ∏è–ó–∞–º–µ—Ç–∏–ª–∏ –æ—à–∏–±–∫—É/–Ω–µ—Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏–µ, –ø–æ–∂–∞–ª—É–π—Å—Ç–∞, <a href=\"https://t.me/Lambarin\">–Ω–∞–ø–∏—à–∏—Ç–µ –º–Ω–µ</a> –≤ –ª–∏—á–Ω—ã–µ —Å–æ–æ–±—â–µ–Ω–∏—è</b>",
                        "buttons": [{
                            "text": "üîô –ù–∞–∑–∞–¥",
                            "callback": "back_inline:cpm_prices"
                        }]
                    },
                    "cpm_range_3": {
                        "label":
                        "–û—Ç 800–°–ü–ú",
                        "text":
                        "<b>–û–¢ 800–°–ü–ú</b>\n\n- –ë–ª–æ–≥–µ—Ä—ã –º–æ–ª–æ–¥–∞—è –¶–ê: 1000+\n- –ë–ª–æ–≥–µ—Ä—ã –≤–∑—Ä–æ—Å–ª–∞—è –¶–ê: 2000+\n- –ü—Å–∏—Ö–æ–ª–æ–≥–∏—è –ñ–¶–ê [–ø—Ä—è–º–æ–π]: 1000-1500\n- –°–∞–º–æ—Ä–∞–∑–≤–∏—Ç–∏–µ –ñ–¶–ê [–ø—Ä—è–º–æ–π]: 1000-1400\n- –°–µ–∫—Å–æ–ª–æ–≥–∏—è/–û—Ç–Ω–æ—à–µ–Ω–∏—è –ñ–¶–ê [–ø—Ä—è–º–æ–π]: 1100-1300\n- –°–µ–∫—Å–æ–ª–æ–≥–∏—è/–û—Ç–Ω–æ—à–µ–Ω–∏—è –ñ–¶–ê [–±–∞–π—Ç]: 1100-1300\n- –ê–≤—Ç–æ—Ä—Å–∫–∏–µ –±–ª–æ–≥–∏: 2000+\n- –ö—Ä–∏–ø—Ç–æ–≤–∞–ª—é—Ç–∞: 200$\n- –ë–∏–∑–Ω–µ—Å/–§–∏–Ω–∞–Ω—Å—ã: 1500-2500\n- –ê–¥–º–∏–Ω—Å–∫–∏–µ –±–ª–æ–≥–∏: 5000+\n- –ê–≤—Ç–æ—Ä—Å–∫–∏–π –º–∞—Ä–∫–µ—Ç–∏–Ω–≥: 5000-20000\n- –ü–∞–±–ª–∏–∫–∏ –ø–æ –º–∞—Ä–∫–µ—Ç–∏–Ω–≥—É: 2500-5000\n- –ù–µ–π—Ä–æ—Å–µ—Ç–∏: 1000+\n- –ê–≤—Ç–æ [–∫—É–ø–ª—è-–ø—Ä–æ–¥–∞–∂–∞]: 950-1100\n- –†–µ–≥–∏–æ–Ω–∞–ª–∫–∏ –ú–°–ö –∏ –ü–ò–¢–ï–†: 1500-2000\n- –ò–≥—Ä—ã: 800-900+- [–¥–ª—è –≤–Ω—É—Ç—Ä–µ–Ω–Ω–µ–≥–æ]\n- –ò–≥—Ä—ã: 1000-1200 [–≤–Ω–µ—à–∫–∞]\n\n<b>‚ùóÔ∏è–ó–∞–º–µ—Ç–∏–ª–∏ –æ—à–∏–±–∫—É/–Ω–µ—Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏–µ, –ø–æ–∂–∞–ª—É–π—Å—Ç–∞, <a href=\"https://t.me/Lambarin\">–Ω–∞–ø–∏—à–∏—Ç–µ –º–Ω–µ</a> –≤ –ª–∏—á–Ω—ã–µ —Å–æ–æ–±—â–µ–Ω–∏—è</b>",
                        "buttons": [{
                            "text": "üîô –ù–∞–∑–∞–¥",
                            "callback": "back_inline:cpm_prices"
                        }]
                    }
                }
            },
            "pdp_prices": {
                "label": "–¶–µ–Ω–∞ –ü–î–ü",
                "text":
                "–û–±–Ω–æ–≤–ª–µ–Ω–æ: 22.12.2025\n\n<b>–í—ã–±–µ—Ä–∏—Ç–µ —Ü–µ–Ω–æ–≤–æ–π –¥–∏–∞–ø–∞–∑–æ–Ω</b>",
                "type": "inline",
                "buttons": [{
                    "text": "üîô –ù–∞–∑–∞–¥",
                    "callback": "back_inline:cpm_pdp"
                }],
                "submenu": {
                    "pdp_range_1": {
                        "label":
                        "–î–æ 35–†",
                        "text":
                        "<b>–î–û 35–†</b>\n\n- –î–æ–º/–î–∞—á–∞: 30-35\n- –ü–æ—Å–æ–±–∏—è: 20-25 [–±–∞–π—Ç]\n- –°–µ–∫—Å–æ–ª–æ–≥–∏—è/–û—Ç–Ω–æ—à–µ–Ω–∏—è –ñ–¶–ê: 30-50 [–ø—Ä—è–º–æ–π]\n- –°–µ–∫—Å–æ–ª–æ–≥–∏—è/–û—Ç–Ω–æ—à–µ–Ω–∏—è –ñ–¶–ê: 30-40 [–±–∞–π—Ç]\n- –í—è–∑–∞–Ω–∏–µ/–†—É–∫–æ–¥–µ–ª–∏–µ: 25-35\n- –°–∞–º–æ—Ä–∞–∑–≤–∏—Ç–∏–µ/–ü—Å–∏—Ö–æ–ª–æ–≥–∏—è –ú–¶–ê: 25-30\n- –Æ–º–æ—Ä: 25-35\n- –ü–æ–∑–Ω–∞–≤–∞–ª–∫–∞ –ò—Å—Ç–æ—Ä–∏—è: 30-35 [–ø—Ä—è–º–æ–π]\n- –ü–æ–∑–Ω–∞–≤–∞–ª–∫–∞ –ò—Å—Ç–æ—Ä–∏—è: 10-20 [–±–∞–π—Ç]\n- –ì–æ—Ä–æ—Å–∫–æ–ø: 25-30\n- –ü–ü/–§–∏—Ç–Ω–µ—Å: 25-35\n- –û—Ç–∫—Ä—ã—Ç–∫–∏: 30-35\n- –ó–¥–æ—Ä–æ–≤—å–µ: 30-45\n- WB –º–æ–ª–æ–¥–∞—è: 15-20\n- –î–∏–∑–∞–π–Ω –∏–Ω—Ç–µ—Ä—å–µ—Ä–∞: 35-40\n- –¶–∏—Ç–∞—Ç—ã: 25-30\n- –ü–æ–ª–∏—Ç.–ù–æ–≤–æ—Å—Ç–∏: 20-25\n- –ù–æ–≤–æ—Å—Ç–∏: 20-30 [–±–∞–π—Ç]\n- –¢—Ä–µ—à: 9-10 [–±–∞–π—Ç/–∑–∞—è–≤–∫–∞]\n- –¢—Ä–µ—à: 15-25 [–±–∞–π—Ç/–∞–≤—Ç–æ–ø—Ä–∏—ë–º]\n- –¢—Ä–µ—à: 9-10 [–ø—Ä—è–º–æ–π/–∑–∞—è–≤–∫–∞]\n- –¢—Ä–µ—à: 15-25 [–ø—Ä—è–º–æ–π/–∞–≤—Ç–æ–ø—Ä–∏—ë–º]\n- –í–æ–µ–Ω–∫–∞: 20-25 [–±–∞–π—Ç]\n- –ö–∏–Ω–æ: 20-25\n- –ñ–∏–≤–æ—Ç–Ω—ã–µ: 20-40\n- –≠–∑–æ—Ç–µ—Ä–∏–∫–∞: 25-30\n- –ë—å—é—Ç–∏ –º–æ–ª–æ–¥–∞—è: 15-30\n- –õ–∞–π—Ñ—Ö–∞–∫–∏: 25-35\n- –≠—Ä–æ/–ü—Ä–æ–Ω: 4-5 [–∑–∞—è–≤–∫–∞]\n- –≠—Ä–æ/–ü—Ä–æ–Ω: 8-10 [–∞–≤—Ç–æ–ø—Ä–∏—ë–º]\n\n<b>‚ùóÔ∏è–ó–∞–º–µ—Ç–∏–ª–∏ –æ—à–∏–±–∫—É/–Ω–µ—Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏–µ, –ø–æ–∂–∞–ª—É–π—Å—Ç–∞, <a href=\"https://t.me/Lambarin\">–Ω–∞–ø–∏—à–∏—Ç–µ –º–Ω–µ</a> –≤ –ª–∏—á–Ω—ã–µ —Å–æ–æ–±—â–µ–Ω–∏—è</b>",
                        "buttons": [{
                            "text": "üîô –ù–∞–∑–∞–¥",
                            "callback": "back_inline:pdp_prices"
                        }]
                    },
                    "pdp_range_2": {
                        "label":
                        "–û—Ç 35–†",
                        "text":
                        "<b>–û–¢ 35–†</b>\n\n- –ö—É–ª–∏–Ω–∞—Ä–∏—è: 40-45\n- –ü—Å–∏—Ö–æ–ª–æ–≥–∏—è –ñ–¶–ê: 45-55 [–ø—Ä—è–º–æ–π]\n- –°–∞–º–æ—Ä–∞–∑–≤–∏—Ç–∏–µ –ñ–¶–ê: 45-55 [–ø—Ä—è–º–æ–π]\n- –î–æ–±—Ä—ã–µ –∫–∞–Ω–∞–ª—ã: 40-45\n- –õ–∏—Ç–µ—Ä–∞—Ç—É—Ä–∞/–¶–∏—Ç–∞—Ç—ã: 40-45\n- –°—Ç—Ä–æ–∏—Ç–µ–ª—å—Å—Ç–≤–æ: 40-60\n- –ö—É–ª–∏–Ω–∞—Ä–∏—è: 40-45\n- –ú–∞–º–æ—á–∫–∏: 35-45\n- –ê–≤—Ç–æ/–î–¢–ü: 35-50\n- –ù–æ–≤–æ—Å—Ç–∏: 45-50+ [–ø—Ä—è–º–æ–π]\n- –ò—Å–∫—É—Å—Å—Ç–≤–æ: –¥–æ 50\n- –õ–∏–Ω–≥–≤–∏—Å—Ç–∏–∫–∞: 35-45\n- –ò–≥—Ä—ã: 35-50\n\n<b>‚ùóÔ∏è–ó–∞–º–µ—Ç–∏–ª–∏ –æ—à–∏–±–∫—É/–Ω–µ—Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏–µ, –ø–æ–∂–∞–ª—É–π—Å—Ç–∞, <a href=\"https://t.me/Lambarin\">–Ω–∞–ø–∏—à–∏—Ç–µ –º–Ω–µ</a> –≤ –ª–∏—á–Ω—ã–µ —Å–æ–æ–±—â–µ–Ω–∏—è</b>",
                        "buttons": [{
                            "text": "üîô –ù–∞–∑–∞–¥",
                            "callback": "back_inline:pdp_prices"
                        }]
                    },
                    "pdp_range_3": {
                        "label":
                        "–û—Ç 50–†",
                        "text":
                        "<b>–û–¢ 50–†</b>\n\n–ü–æ—Å–æ–±–∏—è: 50+ [–ø—Ä—è–º–æ–π]\n–ö—Ä–∏–ø—Ç–æ–≤–∞–ª—é—Ç–∞: 2-6$\n–ë–∏–∑–Ω–µ—Å/–§–∏–Ω–∞–Ω—Å—ã: 50-150\n–ê–≤—Ç–æ—Ä—Å–∫–∏–π –º–∞—Ä–∫–µ—Ç–∏–Ω–≥: 100+\n–ü–∞–±–ª–∏–∫–∏ –ø–æ –º–∞—Ä–∫–µ—Ç–∏–Ω–≥—É: 100+\n–ù–µ–π—Ä–æ—Å–µ—Ç–∏: 70-100\n–ê–≤—Ç–æ [–∫—É–ø–ª—è-–ø—Ä–æ–¥–∞–∂–∞]: 65-85\n–ê–¥–º–∏–Ω—Å–∫–∏–µ –±–ª–æ–≥–∏: 150-300\n–†–µ–≥–∏–æ–Ω–∞–ª–∫–∏ –ú–°–ö –∏ –ü–ò–¢–ï–†: 80+\n\n<b>‚ùóÔ∏è–ó–∞–º–µ—Ç–∏–ª–∏ –æ—à–∏–±–∫—É/–Ω–µ—Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏–µ, –ø–æ–∂–∞–ª—É–π—Å—Ç–∞, <a href=\"https://t.me/Lambarin\">–Ω–∞–ø–∏—à–∏—Ç–µ –º–Ω–µ</a> –≤ –ª–∏—á–Ω—ã–µ —Å–æ–æ–±—â–µ–Ω–∏—è</b>",
                        "buttons": [{
                            "text": "üîô –ù–∞–∑–∞–¥",
                            "callback": "back_inline:pdp_prices"
                        }]
                    }
                }
            },
            "sticker_prices": {
                "label": "–¶–µ–Ω—ã –≤ —Å—Ç–∏–∫–µ—Ä–∞—Ö",
                "url": "https://t.me/addstickers/LBR_Stickers",
                "type": "inline"
            }
        }
    },
    "analytics": {
        "label": "üîç –°–µ—Ä–≤–∏—Å—ã –∞–Ω–∞–ª–∏—Ç–∏–∫–∏",
        "text":
        "<b>–ö—Ä–∞—Ç–∫–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ</b>\n\n<a href=\"https://tgstat.ru/x/XXd7V\">TGStat</a> - —Å–µ—Ä–≤–∏—Å –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞ —Ç–µ–ª–µ–≥—Ä–∞–º-–∫–∞–Ω–∞–ª–æ–≤ –∏ —á–∞—Ç–æ–≤ —Å —É–¥–æ–±–Ω—ã–º –∏ –ø—Ä–æ—Å—Ç—ã–º –Ω–∞ –º–æ–π –≤–∑–≥–ª—è–¥ –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–æ–º.\n\n<a href=\"https://telemetr.me/\">Telemetr</a> - —Ç–æ–∂–µ —Å–µ—Ä–≤–∏—Å –ø–æ –∞–Ω–∞–ª–∏–∑—É —Ç–æ–ª—å–∫–æ —Ç–µ–ª–µ–≥—Ä–∞–º-–∫–∞–Ω–∞–ª–æ–≤, –ø–æ–Ω—è—Ç–Ω—ã–π –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å, –º–æ–∂–Ω–æ –ª–µ–≥–∫–æ —Ä–∞–∑–æ–±—Ä–∞—Ç—å—Å—è.\n\n<a href=\"https://t.me/trustat\">Trustat</a> - –º–æ–ª–æ–¥–æ–π –æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω–æ –∫–æ–Ω–∫—É—Ä–µ–Ω—Ç–æ–≤ —Å–µ—Ä–≤–∏—Å –∞–Ω–∞–ª–∏—Ç–∏–∫–∏ —Ç–µ–ª–µ–≥—Ä–∞–º-–∫–∞–Ω–∞–ª–æ–≤, —Ä–µ–∞–ª–∏–∑–æ–≤–∞–Ω–Ω—ã–π –Ω–∞ –¥–∞–Ω–Ω—ã–π –º–æ–º–µ–Ω—Ç –±–µ–∑ —Å–∞–π—Ç–∞, –≤–Ω—É—Ç—Ä–∏ –±–æ—Ç–∞.\n\n<a href=\"https://botstat.io/\">BotStat.io</a> - —Å–µ—Ä–≤–∏—Å –¥–ª—è –∞–Ω–∞–ª–∏—Ç–∏–∫–∏ –±–æ—Ç–æ–≤.",
        "type": "inline",
        "link_preview": False,
        "submenu": {
            "tgstat": {
                "label":
                "TGStat",
                "text":
                "<a href=\"https://tgstat.ru/x/XXd7V\">TGStat</a> - —è —Å—á–∏—Ç–∞—é, —Å–∞–º—ã–π —É–¥–æ–±–Ω—ã–π —Å–µ—Ä–≤–∏—Å –¥–ª—è –∞–Ω–∞–ª–∏—Ç–∏–∫–∏. –° –æ–±—â–µ–π —á–∏—Å–ª–µ–Ω–Ω–æ—Å—Ç—å—é –±–æ–ª–µ–µ 2–º–ª–Ω –∫–∞–Ω–∞–ª–æ–≤ –∏ —á–∞—Ç–æ–≤. –ü–æ –º–∏–º–æ —É–¥–æ–±–Ω–æ–≥–æ –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞ –∏ –±—ã—Å—Ç—Ä–æ–π —Ç–µ—Ö–Ω–∏—á–µ—Å–∫–æ–π –ø–æ–¥–¥–µ—Ä–∂–∫–∏, —Å–µ—Ä–≤–∏—Å –∏–º–µ–µ—Ç –ø—Ä–∏—è—Ç–Ω—É—é —Ü–µ–Ω—É –Ω–∞ –ø—Ä–µ–º–∏—É–º-–ø–æ–¥–ø–∏—Å–∫—É.",
                "buttons": [{
                    "text": "–ü–æ–¥–¥–µ—Ä–∂–∫–∞ + –ü—Ä–æ–º–æ–∫–æ–¥",
                    "callback": "support:tgstat"
                }]
            },
            "telemetr": {
                "label":
                "Telemetr",
                "text":
                "<a href=\"https://telemetr.me/\">Telemetr</a> -  —Å–µ—Ä–≤–∏—Å –¥–ª—è –≥–ª—É–±–æ–∫–æ–π –∞–Ω–∞–ª–∏—Ç–∏–∫–∏ —Ç–µ–ª–µ–≥—Ä–∞–º-–∫–∞–Ω–∞–ª–æ–≤.\n\n–ò–º–µ–µ—Ç –¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –ø–æ–Ω—è—Ç—ã–π –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å, –≤ –∫–æ—Ç–æ—Ä–æ–º –±—É–¥–µ—Ç –Ω–µ —Å–ª–æ–∂–Ω–æ —Ä–∞–∑–æ–±—Ä–∞—Ç—å—Å—è. –ü–æ –º–∏–º–æ —ç—Ç–æ–≥–æ —Å–µ—Ä–≤–∏—Å –æ–±–ª–∞–¥–∞–µ—Ç –æ–ø—Ä–µ–¥–µ–ª—ë–Ω–Ω—ã–º —Å–ø–µ–∫—Ç—Ä–æ–º —Ç–µ–º–∞—Ç–∏–∫ –∫–æ—Ç–æ—Ä—ã—Ö –Ω–µ—Ç –Ω–∞ —Ç–≥—Å—Ç–∞—Ç –∏ –¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –±—ã—Å—Ç—Ä–æ–π —Ç–µ—Ö–Ω–∏—á–µ—Å–∫–æ–π –ø–æ–¥–¥–µ—Ä–∂–∫–æ–π.",
                "buttons": [{
                    "text": "–ü–æ–¥–¥–µ—Ä–∂–∫–∞ + –ü—Ä–æ–º–æ–∫–æ–¥",
                    "callback": "support:telemetr"
                }]
            },
            "trustat": {
                "label": "Trustat",
                "text":
                "<a href=\"https://t.me/trustat\">Trustat</a> - –º–æ–ª–æ–¥–æ–π, –æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω–æ –∫–æ–Ω–∫—É—Ä–µ–Ω—Ç–æ–≤, –Ω–æ –¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ  –ø–µ—Ä—Å–ø–µ–∫—Ç–∏–≤–Ω—ã–π —Å–µ—Ä–≤–∏—Å –∞–Ω–∞–ª–∏—Ç–∏–∫–∏ —Ç–µ–ª–µ–≥—Ä–∞–º-–∫–∞–Ω–∞–ª–æ–≤, —Å —Ä–µ–∞–ª–∏–∑–æ–≤–∞–Ω–Ω—ã–º —Ñ—É–Ω–∫—Ü–∏–æ–Ω–∞–ª–æ–º –ø–æ–∫–∞ —á—Ç–æ –ª–∏—à—å –≤–Ω—É—Ç—Ä–∏ –±–æ—Ç–∞. \n\n–ù–∞ –º–æ–π –≤–∑–≥–ª—è–¥ –¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ —É–¥–æ–±–Ω—ã–π, –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –±—ã—Å—Ç—Ä–æ–π —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ —Å—Ä–∞–∑—É –ø–æ –Ω–µ—Å–∫–æ–ª—å–∫–∏–º —Ç–µ–ª–µ–≥—Ä–∞–º-–∫–∞–Ω–∞–ª–∞–º.",
                "buttons": [{
                    "text": "–ü–æ–¥–¥–µ—Ä–∂–∫–∞",
                    "callback": "support:trustat"
                }]
            },
            "botstat": {
                "label": "BotStat.io",
                "text":
                "<a href=\"https://botstat.io/\">BotStat.io</a> - —Å–µ—Ä–≤–∏—Å –¥–ª—è –∞–Ω–∞–ª–∏—Ç–∏–∫–∏ —Ç–µ–ª–µ–≥—Ä–∞–º-–±–æ—Ç–æ–≤ —Å –ø–æ–∫–∞–∑–∞—Ç–µ–ª—è–º–∏ –∂–∏–≤—ã—Ö/–º–µ—Ä—Ç–≤—ã—Ö/–ø—Ä–∏—Ä–æ—Å—Ç –∑–∞ 30 –¥–Ω–µ–π –∏ –º–Ω–æ–≥–æ–µ –¥—Ä—É–≥–æ–µ. –ú–æ–∂–Ω–æ —Å–∫–∞–∑–∞—Ç—å —Å–≤–æ–µ–≥–æ —Ä–æ–¥–∞ —Ç–≥—Å—Ç–∞—Ç, –Ω–æ –¥–ª—è –±–æ—Ç–æ–≤.",
                "buttons": [{
                    "text": "–ü–æ–¥–¥–µ—Ä–∂–∫–∞",
                    "callback": "support:botstat"
                }]
            }
        }
    },
    "chats": {
        "label": "üí¨ –ß–∞—Ç—ã",
        "text": "<b>–í—ã–±–µ—Ä–∏—Ç–µ –∫–∞—Ç–µ–≥–æ—Ä–∏—é —á–∞—Ç–æ–≤</b>",
        "type": "inline",
        "submenu": {
            "infobusiness": {
                "label":
                "–ò–Ω—Ñ–æ–±–∏–∑",
                "text":
                "–ü–æ–ª–Ω—ã–π —Å–ø–∏—Å–æ–∫ —á–∞—Ç–æ–≤ –ø–æ –∏–Ω—Ñ–æ–±–∏–∑–Ω–µ—Å—É –∏ –º–∞—Ä–∫–µ—Ç–∏–Ω–≥—É –Ω–∞—Ö–æ–¥–∏—Ç—Å—è <a href=\"https://t.me/LBR_Chats/35\">–∑–¥–µ—Å—å</a>"
            },
            "thematic_admin": {
                "label":
                "–¢–µ–º–∞—Ç–∏—á–µ—Å–∫–∏–µ [–∞–¥–º–∏–Ω]",
                "text":
                "–° –ø–æ–ª–Ω—ã–º —Å–ø–∏—Å–∫–æ–º —Ç–µ–º–∞—Ç–∏—á–µ—Å–∫–∏—Ö –∞–¥–º–∏–Ω—Å–∫–∏—Ö —á–∞—Ç–æ–≤ –º–æ–∂–Ω–æ –æ–∑–Ω–∞–∫–æ–º–∏—Ç—å—Å—è <a href=\"https://t.me/LBR_Chats/32\">–∑–¥–µ—Å—å</a>"
            },
            "general_admin": {
                "label":
                "–û–±—â–∏–µ [–∞–¥–º–∏–Ω]",
                "text":
                "–° –ø–æ–ª–Ω—ã–º —Å–ø–∏—Å–∫–æ–º –æ–±—â–∏—Ö –∞–¥–º–∏–Ω—Å–∫–∏—Ö —á–∞—Ç–æ–≤ –º–æ–∂–Ω–æ –æ–∑–Ω–∞–∫–æ–º–∏—Ç—å—Å—è <a href=\"https://t.me/LBR_Chats/33\">–∑–¥–µ—Å—å</a>"
            },
            "business_chats": {
                "label":
                "–ë–∏–∑–Ω–µ—Å",
                "text":
                "–° –ø–æ–ª–Ω—ã–º —Å–ø–∏—Å–∫–æ–º –±–∏–∑–Ω–µ—Å —á–∞—Ç–æ–≤, –∫–æ–º—å—é–Ω–∏—Ç–∏ –º–æ–∂–Ω–æ –æ–∑–Ω–∞–∫–æ–º–∏—Ç—å—Å—è <a href=\"https://t.me/LBR_Chats/34\">–∑–¥–µ—Å—å</a>"
            }
        }
    },
    "bots": {
        "label": "ü§ñ –†–∞–∑–ª–∏—á–Ω—ã–µ –±–æ—Ç—ã",
        "text": "<b>–ö–∞–∫–æ–≥–æ –±–æ—Ç–∞ –∏—â–∏—Ç–µ?</b>",
        "type": "inline",
        "submenu": {
            "chat_bots": {
                "label":
                "–î–ª—è —á–∞—Ç–æ–≤",
                "text":
                "<b>ü§ñ–ë–æ—Ç—ã –¥–ª—è –º–æ–¥–µ—Ä–∞—Ü–∏–∏ —á–∞—Ç–æ–≤</b>\n- @GHClone5Bot\n- @ChatKeeperBot | <a href=\"https://t.me/ChatKeeperBotSupport\">–ü–æ–¥–¥–µ—Ä–∂–∫–∞</a>\n- @combot | <a href=\"https://t.me/combotru\">–ü–æ–¥–¥–µ—Ä–∂–∫–∞</a>"
            },
            "auto_posting": {
                "label":
                "–ê–≤—Ç–æ-–ü–æ—Å—Ç–∏–Ω–≥",
                "text":
                "<b>ü§ñ–ë–æ—Ç—ã –∞–≤—Ç–æ-–ø–æ—Å—Ç–∏–Ω–≥–∞</b>\n- @postal | <a href=\"https://t.me/postal_support\">–ü–æ–¥–¥–µ—Ä–∂–∫–∞</a>\n- <a href=\"https://t.me/posted?start=1070947810\">@posted</a> | <a href=\"https://t.me/PostedSupport\">–ü–æ–¥–¥–µ—Ä–∂–∫–∞</a>\n- @rekla | <a href=\"https://t.me/rekla_support\">–ü–æ–¥–¥–µ—Ä–∂–∫–∞</a>"
            },
            "analytics_bots": {
                "label":
                "–°–µ—Ä–≤–∏—Å—ã –∞–Ω–∞–ª–∏—Ç–∏–∫–∏",
                "text":
                "<b>ü§ñ–ë–æ—Ç—ã —Å–µ—Ä–≤–∏—Å–æ–≤ –∞–Ω–∞–ª–∏—Ç–∏–∫–∏</b>\n@TGStat_Bot | <a href=\"https://t.me/TGStatSupportBot\">–ü–æ–¥–¥–µ—Ä–∂–∫–∞</a>\n@telemetrmebot | <a href=\"https://t.me/TelemetrSupport\">–ü–æ–¥–¥–µ—Ä–∂–∫–∞</a>\n@BotStatRobot | <a href=\"https://t.me/BotStatContact\">–ü–æ–¥–¥–µ—Ä–∂–∫–∞</a>\n@trustat | <a href=\"https://t.me/TrustatSupport\">–ü–æ–¥–¥–µ—Ä–∂–∫–∞</a>"
            },
            "greeting_bots": {
                "label":
                "–ë–æ—Ç—ã-–ü—Ä–∏–≤–µ—Ç—Å—Ç–≤–∏—è",
                "text":
                "<b>ü§ñ–ë–æ—Ç—ã-–ø—Ä–∏–≤–µ—Ç—Å—Ç–≤–∏—è</b>\n@go_postal_robot | <a href=\"https://t.me/postal_support\">–ü–æ–¥–¥–µ—Ä–∂–∫–∞</a>"
            }
        }
    },
    "useful_sites": {
        "label": "üìö –ü–æ–ª–µ–∑–Ω—ã–µ —Å–∞–π—Ç—ã",
        "text": "<b>–ö–∞–∫–æ–π —Å–∞–π—Ç –∏—â–∏—Ç–µ?</b>",
        "type": "inline",
        "submenu": {
            "article_sites": {
                "label":
                "–ù–∞–ø–∏—Å–∞—Ç—å —Å—Ç–∞—Ç—å—é",
                "text":
                "<b>üìö–°–∞–π—Ç—ã –¥–ª—è –Ω–∞–ø–∏—Å–∞–Ω–∏—è —Å—Ç–∞—Ç–µ–π</b>\n\n- <a href=\"https://telegra.ph/\">Telega.ph</a>\n- <a href=\"https://teletype.in/\">Teletype.in</a>"
            },
            "telegram_sites": {
                "label":
                "–¢–µ–ª–µ–≥—Ä–∞–º",
                "text":
                "<b>üåê–°–∞–π—Ç—ã Telegram:</b>\n\n- <b><a href=\"https://telegram.org/\">–û—Ñ–∏—Ü–∏–∞–ª—å–Ω—ã–π —Å–∞–π—Ç Telegram</a></b>\n- <b><a href=\"https://desktop.telegram.org/\">–°–∫–∞—á–∞—Ç—å –∏ —É—Å—Ç–∞–Ω–æ–≤–∏—Ç—å desktop –≤–µ—Ä—Å–∏—é</a></b>\n- <b><a href=\"https://bugs.telegram.org/\">–ü—Ä–µ–¥–ª–æ–∂–∏—Ç—å –∏–¥–µ—é/—Å–æ–æ–±—â–∏—Ç—å –æ –±–∞–≥–µ</a></b>\n- <b><a href=\"https://web.telegram.org/\">–í–µ–±-–≤–µ—Ä—Å–∏—è</a></b>\n- <b><a href=\"http://promote.telegram.org/\">–†–µ–∫–ª–∞–º–Ω–∞—è –ø–ª–æ—â–∞–¥–∫–∞</a></b>\n- <b><a href=\"https://my.telegram.org/deactivate\">–£–¥–∞–ª–∏—Ç—å –∞–∫–∫–∞—É–Ω—Ç</a></b>"
            }
        }
    },
    "promo_codes": {
        "label":
        "üéÅ –ü—Ä–æ–º–æ–∫–æ–¥—ã",
        "text":
        "<b>–°–ø–∏—Å–æ–∫ –ø—Ä–æ–º–æ–∫–æ–¥–æ–≤</b>\n\n<b><a href=\"https://tgstat.ru/x/XXd7V\">TGStat</a></b> - <code>Lambarin</code> [5%]\n\n<b><a href=\"https://telemetr.me/\">Telemetr</a></b> - <code>Lambarin</code> [10%]\n\n<b><a href=\"https://t.me/posted?start=1070947810\">@Posted</a></b> - <code>Lambarin</code> [20%]"
    }
}


def get_dynamic_keyboard(user_id=None):
    keyboard = []
    row = []
    for key, menu in MENU_STRUCTURE.items():
        row.append(KeyboardButton(text=menu['label']))
        if len(row) == 2:
            keyboard.append(row)
            row = []

    # –î–æ–±–∞–≤–ª—è–µ–º –¥–∏–Ω–∞–º–∏—á–µ—Å–∫–∏–µ –∫–Ω–æ–ø–∫–∏ –∏–∑ –ë–î
    try:
        import asyncio
        from database import get_all_keyboard_buttons
        # This is a bit tricky since get_dynamic_keyboard is likely called in sync context or needs await
        # Assuming it's used in an async handler, we should make it async
        pass 
    except: pass

    if row:
        keyboard.append(row)

    if ADMIN_ID and user_id == ADMIN_ID:
        keyboard.append([KeyboardButton(text="üîê –ê–¥–º–∏–Ω-–ø–∞–Ω–µ–ª—å")])
    return ReplyKeyboardMarkup(keyboard=keyboard, resize_keyboard=True)

async def get_dynamic_keyboard_async(user_id=None):
    keyboard = []
    row = []
    for key, menu in MENU_STRUCTURE.items():
        row.append(KeyboardButton(text=menu['label']))
        if len(row) == 2:
            keyboard.append(row)
            row = []

    # –î–æ–±–∞–≤–ª—è–µ–º –¥–∏–Ω–∞–º–∏—á–µ—Å–∫–∏–µ –∫–Ω–æ–ø–∫–∏ –∏–∑ –ë–î
    dynamic_btns = await get_all_keyboard_buttons()
    for btn in dynamic_btns:
        lbl = btn['label']
        # –ü—Ä–æ–ø—É—Å–∫–∞–µ–º –ø—Ä–∏–∑—Ä–∞–∫–æ–≤
        if lbl.lower().strip() in ["—É–¥–∞–ª–∏—Ç—å lambi", "—É–¥–∞–ª–∏—Ç—å –ª–∞–º–±–∏", "üìù —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å —á–∞—Ç—ã"]:
            continue
        row.append(KeyboardButton(text=lbl))
        if len(row) == 2:
            keyboard.append(row)
            row = []

    if row:
        keyboard.append(row)

    if ADMIN_ID and user_id == ADMIN_ID:
        keyboard.append([KeyboardButton(text="üîê –ê–¥–º–∏–Ω-–ø–∞–Ω–µ–ª—å")])
    return ReplyKeyboardMarkup(keyboard=keyboard, resize_keyboard=True)


def get_submenu_keyboard(menu_key, parent_sub_key=None):
    menu = MENU_STRUCTURE.get(menu_key)
    if not menu or 'submenu' not in menu:
        return None

    # If parent_sub_key is specified, get the nested submenu
    if parent_sub_key:
        sub_menu = menu['submenu'].get(parent_sub_key)
        if not sub_menu or 'submenu' not in sub_menu:
            return None
        submenu_dict = sub_menu['submenu']
    else:
        submenu_dict = menu['submenu']

    keyboard = []
    row = []
    for sub_key, sub_menu in submenu_dict.items():
        row.append(KeyboardButton(text=sub_menu['label']))
        if len(row) == 2:
            keyboard.append(row)
            row = []
    if row:
        keyboard.append(row)
    keyboard.append([KeyboardButton(text="üîô –ù–∞–∑–∞–¥ –≤ –º–µ–Ω—é")])
    return ReplyKeyboardMarkup(keyboard=keyboard, resize_keyboard=True)


def get_nav_keyboard_inline(menu_key, sub_key, page_index):
    """For multi-page sections like terminology"""
    # Support for deep search if menu_key is empty (used for deep inline pages)
    menu = None
    if menu_key and menu_key in MENU_STRUCTURE:
        menu = MENU_STRUCTURE[menu_key]
        if sub_key and 'submenu' in menu and sub_key in menu['submenu']:
            menu = menu['submenu'][sub_key]
    else:
        # Deep search for sub_key
        for m_key, m_data in MENU_STRUCTURE.items():
            if m_key == sub_key:
                menu = m_data
                break
            if 'submenu' in m_data:
                if sub_key in m_data['submenu']:
                    menu = m_data['submenu'][sub_key]
                    break
                for s_key, s_data in m_data['submenu'].items():
                    if 'submenu' in s_data and sub_key in s_data['submenu']:
                        menu = s_data['submenu'][sub_key]
                        break
            if menu: break

    if not menu:
        return None

    keyboard = []
    buttons = []

    if 'pages' in menu:
        total_pages = len(menu['pages'])
    else:
        return None

    if page_index > 0:
        buttons.append(
            InlineKeyboardButton(
                text="‚óÄÔ∏è",
                callback_data=f"page:{menu_key}:{sub_key}:{page_index-1}"))

    buttons.append(
        InlineKeyboardButton(text=f"{page_index+1}/{total_pages}",
                             callback_data="noop"))

    if page_index < total_pages - 1:
        buttons.append(
            InlineKeyboardButton(
                text="‚ñ∂Ô∏è",
                callback_data=f"page:{menu_key}:{sub_key}:{page_index+1}"))

    keyboard.append(buttons)

    return InlineKeyboardMarkup(inline_keyboard=keyboard)


async def edit_message_safe(query: types.CallbackQuery,
                            text: str,
                            reply_markup,
                            parse_mode=ParseMode.HTML,
                            link_preview_disabled=True):
    """Safely edit message in both regular and inline modes"""
    if query.message:
        # Regular message edit
        await query.message.edit_text(text,
                                      reply_markup=reply_markup,
                                      parse_mode=parse_mode,
                                      link_preview_options=LinkPreviewOptions(
                                          is_disabled=link_preview_disabled))
    elif query.inline_message_id:
        # Inline message edit
        await bot.edit_message_text(inline_message_id=query.inline_message_id,
                                    text=text,
                                    reply_markup=reply_markup,
                                    parse_mode=parse_mode,
                                    link_preview_options=LinkPreviewOptions(
                                        is_disabled=link_preview_disabled))


async def get_dynamic_keyboard(user_id=None):
    """–ì–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç –≥–ª–∞–≤–Ω—É—é –∫–ª–∞–≤–∏–∞—Ç—É—Ä—É, –≤–∫–ª—é—á–∞—è –¥–∏–Ω–∞–º–∏—á–µ—Å–∫–∏–µ –∫–Ω–æ–ø–∫–∏ –∏–∑ –ë–î."""
    keyboard = []
    row = []
    for key, menu in MENU_STRUCTURE.items():
        row.append(KeyboardButton(text=menu['label']))
        if len(row) == 2:
            keyboard.append(row)
            row = []

    # –î–æ–±–∞–≤–ª—è–µ–º –¥–∏–Ω–∞–º–∏—á–µ—Å–∫–∏–µ –∫–Ω–æ–ø–∫–∏ —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –æ–Ω–∏ —Å—É—â–µ—Å—Ç–≤—É—é—Ç
    dynamic_btns = await get_all_keyboard_buttons()
    for btn in dynamic_btns:
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞ —Å–∏—Å—Ç–µ–º–Ω—ã–µ –∏–º–µ–Ω–∞ –∏ –ø—É—Å—Ç—ã–µ –ª–µ–π–±–ª—ã
        lbl = btn['label'].lower().strip()
        if not btn['label'] or lbl in ["—É–¥–∞–ª–∏—Ç—å lambi", "üìù —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å —á–∞—Ç—ã", "—É–¥–∞–ª–∏—Ç—å –ª–∞–º–±–∏"]:
            continue
        row.append(KeyboardButton(text=btn['label']))
        if len(row) == 2:
            keyboard.append(row)
            row = []

    if row:
        keyboard.append(row)
    if ADMIN_ID and user_id == ADMIN_ID:
        keyboard.append([KeyboardButton(text="üîê –ê–¥–º–∏–Ω-–ø–∞–Ω–µ–ª—å")])
    return ReplyKeyboardMarkup(keyboard=keyboard, resize_keyboard=True)

@router.message(Command("start"))
async def cmd_start(message: types.Message, state: FSMContext):
    await state.clear()
    user_id = message.from_user.id
    try:
        await add_user(user_id, message.from_user.username,
                       message.from_user.first_name, message.from_user.last_name)
    except Exception as e:
        logger.error(f"Error adding user in start: {e}")

    user_name = message.from_user.first_name or "–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å"
    user_link = f'<a href="tg://user?id={user_id}">{user_name}</a>'
    start_text = (
        f"<b>–ü—Ä–∏–≤–µ—Ç</b>, {user_link} üòé\n\n"
        "–ú–µ–Ω—è –∑–æ–≤—É—Ç –õ–∞–º–±–∏, —è –ø–æ–º–æ–≥—É —Å –ø–æ–∏—Å–∫–æ–º –Ω—É–∂–Ω–æ–π —Ç–µ–±–µ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏.\n\n"
        "–ê –±–ª–∞–≥–æ–¥–∞—Ä—è –∏–Ω–ª–∞–π–Ω-—Ä–µ–∂–∏–º—É, —Ç—ã –º–æ–∂–µ—à—å –¥–µ–ª–∏—Ç—å—Å—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–µ–π –Ω–µ —Ç–æ–ª—å–∫–æ –±—ã—Å—Ç—Ä–æ –∏ –≤ –ø–∞—Ä—É –∫–ª–∏–∫–æ–≤, –Ω–æ –∏ –≥–¥–µ —É–≥–æ–¥–Ω–æ: –≤ –ª–∏—á–Ω—ã—Ö –ø–µ—Ä–µ–ø–∏—Å–∫–∞—Ö, —á–∞—Ç–∞—Ö –∏ –∫–∞–Ω–∞–ª–∞—Ö.\n"
        "<blockquote>–ß—Ç–æ–±—ã –≤–æ—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å—Å—è –∏–Ω–ª–∞–π–Ω-—Ä–µ–∂–∏–º–æ–º, –≤–≤–µ–¥–∏ –≤ —Å—Ç—Ä–æ–∫–µ –≤–≤–æ–¥–∞ —Å–æ–æ–±—â–µ–Ω–∏—è —é–∑–µ—Ä –±–æ—Ç–∞ –∏ –≤—ã–±–∏—Ä–∞–π –Ω—É–∂–Ω—ã–π –ø—É–Ω–∫—Ç</blockquote>\n\n"
        "<b>–ë–ª–æ–≥ –≤–ª–∞–¥–µ–ª—å—Ü–∞: t.me/+2m6vI9IYsBA0NTYy</b>\n"
        "<b>–õ—É—á—à–∏–π —á–∞—Ç: t.me/+Mo58T7pcKxpmNjYy</b>")
    keyboard = await get_dynamic_keyboard(user_id)
    try:
        await message.answer_photo(photo=types.FSInputFile("start_image.jpg"),
                                   caption=start_text,
                                   reply_markup=keyboard,
                                   parse_mode=ParseMode.HTML)
    except Exception:
        await message.answer(start_text, reply_markup=keyboard, parse_mode=ParseMode.HTML)

@router.message(F.text == "üîê –ê–¥–º–∏–Ω-–ø–∞–Ω–µ–ª—å")
async def admin_button(message: types.Message, state: FSMContext):
    if message.from_user.id != ADMIN_ID:
        await message.answer("–£ –≤–∞—Å –Ω–µ—Ç –¥–æ—Å—Ç—É–ø–∞ –∫ –∞–¥–º–∏–Ω-–ø–∞–Ω–µ–ª–∏.")
        return
    admin_keyboard = ReplyKeyboardMarkup(
        keyboard=[[KeyboardButton(text="üì¢ –†–∞—Å—Å—ã–ª–∫–∞")],
                  [KeyboardButton(text="üìä –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞")],
                  [KeyboardButton(text="üèó –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –º–µ–Ω—é")],
                  [KeyboardButton(text="‚úèÔ∏è –†–µ–¥–∞–∫—Ç–æ—Ä –∫–æ–Ω—Ç–µ–Ω—Ç–∞")],
                  [KeyboardButton(text="üîô –í—ã–π—Ç–∏")]],
        resize_keyboard=True)
    await message.answer("üîê <b>–ê–¥–º–∏–Ω-–ø–∞–Ω–µ–ª—å</b>\n\n–í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ:",
                         reply_markup=admin_keyboard,
                         parse_mode=ParseMode.HTML)

class AdminMenuStates(StatesGroup):
    main = State()
    managing_menu = State()
    adding_button_label = State()
    adding_button_content = State()
    adding_button_photo = State()
    adding_inline_button_text = State()
    adding_inline_button_url = State()
    confirming_button = State()
    creating_nested = State() # For deep nesting
    button_action_menu = State()  # –ú–µ–Ω—é –¥–µ–π—Å—Ç–≤–∏–π –Ω–∞–¥ –∫–Ω–æ–ø–∫–æ–π
    renaming_button = State()  # –ü–µ—Ä–µ–∏–º–µ–Ω–æ–≤–∞–Ω–∏–µ –∫–Ω–æ–ø–∫–∏

@router.message(F.text == "üèó –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –º–µ–Ω—é")
async def manage_menu(message: types.Message, state: FSMContext):
    if message.from_user.id != ADMIN_ID: return
    buttons = await get_all_keyboard_buttons()
    text = "üèó <b>–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –º–µ–Ω—é</b>\n\n–í—ã–±–µ—Ä–∏—Ç–µ –∫–Ω–æ–ø–∫—É –¥–ª—è —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –∏–ª–∏ —Å–æ–∑–¥–∞–π—Ç–µ –Ω–æ–≤—É—é."
    kb = []
    for btn in buttons:
        kb.append([KeyboardButton(text=f"‚öôÔ∏è {btn['label']}")])
    kb.append([KeyboardButton(text="‚ûï –°–æ–∑–¥–∞—Ç—å –Ω–æ–≤—É—é –∫–Ω–æ–ø–∫—É")])
    kb.append([KeyboardButton(text="‚¨ÖÔ∏è –ù–∞–∑–∞–¥")])
    await state.set_state(AdminMenuStates.managing_menu)
    await message.answer(text, reply_markup=ReplyKeyboardMarkup(keyboard=kb, resize_keyboard=True), parse_mode=ParseMode.HTML)

@router.message(AdminMenuStates.managing_menu)
async def process_menu_management(message: types.Message, state: FSMContext):
    if message.text == "‚ûï –°–æ–∑–¥–∞—Ç—å –Ω–æ–≤—É—é –∫–Ω–æ–ø–∫—É":
        await state.set_state(AdminMenuStates.adding_button_label)
        await message.answer("–í–≤–µ–¥–∏—Ç–µ –Ω–∞–∑–≤–∞–Ω–∏–µ –¥–ª—è –∫–Ω–æ–ø–∫–∏:", reply_markup=ReplyKeyboardMarkup(keyboard=[[KeyboardButton(text="‚¨ÖÔ∏è –û—Ç–º–µ–Ω–∞")]], resize_keyboard=True))
    elif message.text.startswith("‚öôÔ∏è "):
        # –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –º–µ–Ω—é —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–π –∫–Ω–æ–ø–∫–æ–π
        label = message.text[2:]
        await state.update_data(selected_button_label=label)
        kb = [
            [KeyboardButton(text="‚úèÔ∏è –ü–µ—Ä–µ–∏–º–µ–Ω–æ–≤–∞—Ç—å")],
            [KeyboardButton(text="‚ùå –£–¥–∞–ª–∏—Ç—å")],
            [KeyboardButton(text="‚¨ÖÔ∏è –ù–∞–∑–∞–¥")]
        ]
        await state.set_state(AdminMenuStates.button_action_menu)
        await message.answer(
            f"‚öôÔ∏è <b>–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –∫–Ω–æ–ø–∫–æ–π: {label}</b>\n\n–í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ:",
            reply_markup=ReplyKeyboardMarkup(keyboard=kb, resize_keyboard=True),
            parse_mode=ParseMode.HTML
        )
    elif message.text == "‚¨ÖÔ∏è –ù–∞–∑–∞–¥":
        await admin_button(message, state)

@router.message(AdminMenuStates.button_action_menu)
async def process_button_action(message: types.Message, state: FSMContext):
    """–û–±—Ä–∞–±–æ—Ç–∫–∞ –¥–µ–π—Å—Ç–≤–∏–π –Ω–∞–¥ –≤—ã–±—Ä–∞–Ω–Ω–æ–π –∫–Ω–æ–ø–∫–æ–π"""
    if message.text == "‚¨ÖÔ∏è –ù–∞–∑–∞–¥":
        return await manage_menu(message, state)

    data = await state.get_data()
    label = data.get('selected_button_label')

    if message.text == "‚ùå –£–¥–∞–ª–∏—Ç—å":
        if await delete_keyboard_button(label):
            await message.answer(f"‚úÖ –ö–Ω–æ–ø–∫–∞ '{label}' —É–¥–∞–ª–µ–Ω–∞.")
        else:
            await message.answer(f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ —É–¥–∞–ª–µ–Ω–∏–∏ –∫–Ω–æ–ø–∫–∏ '{label}'")
        return await manage_menu(message, state)

    elif message.text == "‚úèÔ∏è –ü–µ—Ä–µ–∏–º–µ–Ω–æ–≤–∞—Ç—å":
        await state.set_state(AdminMenuStates.renaming_button)
        await message.answer(
            f"‚úèÔ∏è –ü–µ—Ä–µ–∏–º–µ–Ω–æ–≤–∞–Ω–∏–µ –∫–Ω–æ–ø–∫–∏ <b>{label}</b>\n\n–í–≤–µ–¥–∏—Ç–µ –Ω–æ–≤–æ–µ –Ω–∞–∑–≤–∞–Ω–∏–µ:",
            reply_markup=ReplyKeyboardMarkup(
                keyboard=[[KeyboardButton(text="‚¨ÖÔ∏è –û—Ç–º–µ–Ω–∞")]],
                resize_keyboard=True
            ),
            parse_mode=ParseMode.HTML
        )

@router.message(AdminMenuStates.renaming_button)
async def process_button_rename(message: types.Message, state: FSMContext):
    """–û–±—Ä–∞–±–æ—Ç–∫–∞ –ø–µ—Ä–µ–∏–º–µ–Ω–æ–≤–∞–Ω–∏—è –∫–Ω–æ–ø–∫–∏ –∫–ª–∞–≤–∏–∞—Ç—É—Ä—ã"""
    if message.text == "‚¨ÖÔ∏è –û—Ç–º–µ–Ω–∞":
        return await manage_menu(message, state)

    data = await state.get_data()
    old_label = data.get('selected_button_label')
    new_label = message.text.strip()

    if not new_label:
        await message.answer("‚ùå –ù–∞–∑–≤–∞–Ω–∏–µ –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º")
        return

    # –ü–µ—Ä–µ–∏–º–µ–Ω–æ–≤—ã–≤–∞–µ–º –∫–Ω–æ–ø–∫—É –≤ –ë–î
    success = await rename_keyboard_button(old_label, new_label)

    if success:
        await message.answer(f"‚úÖ –ö–Ω–æ–ø–∫–∞ –ø–µ—Ä–µ–∏–º–µ–Ω–æ–≤–∞–Ω–∞: '{old_label}' ‚Üí '{new_label}'")
    else:
        await message.answer(f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–µ—Ä–µ–∏–º–µ–Ω–æ–≤–∞–Ω–∏–∏ –∫–Ω–æ–ø–∫–∏")

    await manage_menu(message, state)

@router.message(AdminMenuStates.adding_button_label)
async def add_btn_label(message: types.Message, state: FSMContext):
    if message.text == "‚¨ÖÔ∏è –û—Ç–º–µ–Ω–∞": return await manage_menu(message, state)
    await state.update_data(label=message.text)
    await state.set_state(AdminMenuStates.adding_button_content)
    await message.answer("–í–≤–µ–¥–∏—Ç–µ —Ç–µ–∫—Å—Ç —Å–æ–æ–±—â–µ–Ω–∏—è (–ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è HTML):")

@router.message(AdminMenuStates.adding_button_content)
async def add_btn_content(message: types.Message, state: FSMContext):
    if message.text == "‚¨ÖÔ∏è –û—Ç–º–µ–Ω–∞": return await manage_menu(message, state)
    await state.update_data(content=message.text)
    await state.set_state(AdminMenuStates.adding_button_photo)
    await message.answer("–û—Ç–ø—Ä–∞–≤—å—Ç–µ —Ñ–æ—Ç–æ –∏–ª–∏ –Ω–∞–ø–∏—à–∏—Ç–µ '–ø—Ä–æ–ø—É—Å—Ç–∏—Ç—å':", 
                         reply_markup=ReplyKeyboardMarkup(keyboard=[[KeyboardButton(text="–ø—Ä–æ–ø—É—Å—Ç–∏—Ç—å")], [KeyboardButton(text="‚¨ÖÔ∏è –û—Ç–º–µ–Ω–∞")]], resize_keyboard=True))

@router.message(AdminMenuStates.adding_button_photo)
async def add_btn_photo(message: types.Message, state: FSMContext):
    if message.text == "‚¨ÖÔ∏è –û—Ç–º–µ–Ω–∞": return await manage_menu(message, state)
    photo = message.photo[-1].file_id if message.photo else None
    await state.update_data(photo=photo, inline_buttons_list=[]) # Initialize list
    await state.set_state(AdminMenuStates.adding_inline_button_text)
    await message.answer("–í–≤–µ–¥–∏—Ç–µ —Ç–µ–∫—Å—Ç –¥–ª—è –∏–Ω–ª–∞–π–Ω-–∫–Ω–æ–ø–∫–∏ (–∏–ª–∏ '–∑–∞–≤–µ—Ä—à–∏—Ç—å'):",
                         reply_markup=ReplyKeyboardMarkup(keyboard=[[KeyboardButton(text="–∑–∞–≤–µ—Ä—à–∏—Ç—å")], [KeyboardButton(text="‚¨ÖÔ∏è –û—Ç–º–µ–Ω–∞")]], resize_keyboard=True))

@router.message(AdminMenuStates.adding_inline_button_text)
async def add_inline_text(message: types.Message, state: FSMContext):
    if message.text == "‚¨ÖÔ∏è –û—Ç–º–µ–Ω–∞": return await manage_menu(message, state)
    if message.text == "–∑–∞–≤–µ—Ä—à–∏—Ç—å":
        data = await state.get_data()
        await finalize_creation(message, state, data)
        return
    await state.update_data(inline_label=message.text)
    await state.set_state(AdminMenuStates.adding_inline_button_url)
    await message.answer("–í–≤–µ–¥–∏—Ç–µ —Å—Å—ã–ª–∫—É (URL) –∏–ª–∏ '–º–µ–Ω—é' –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è –≤–ª–æ–∂–µ–Ω–Ω–æ–≥–æ —Ä–∞–∑–¥–µ–ª–∞:",
                         reply_markup=ReplyKeyboardMarkup(keyboard=[[KeyboardButton(text="–º–µ–Ω—é")], [KeyboardButton(text="‚¨ÖÔ∏è –û—Ç–º–µ–Ω–∞")]], resize_keyboard=True))

async def process_dynamic_inline(query: types.CallbackQuery, state: FSMContext):
    """Handler for all dynamic inline buttons (callback_data starts with 'dyn:')"""
    button_id = query.data[4:]
    logger.info(f"üîÑ Processing dynamic button: {button_id}")

    # Log click for statistics
    await log_click(button_id)

    item = await get_button_content(button_id)
    if not item:
        # Fallback to simple external link behavior if not in DB
        await query.answer("–ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –≤—Ä–µ–º–µ–Ω–Ω–æ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–∞.", show_alert=True)
        return

    # Check for inline buttons
    reply_markup = None
    if item['buttons_json']:
        try:
            btns_data = json.loads(item['buttons_json'])
            inline_kb = []
            for b in btns_data:
                # If the button has a URL, it's an external link
                if b.get('url') and b.get('url') != '–º–µ–Ω—é':
                    inline_kb.append([InlineKeyboardButton(text=b['text'], url=b['url'])])
                # If it's a nested menu link
                else:
                    # The button ID for the submenu is the one stored in data or label+text
                    # We use nested_id from creation: parent_id + ":" + b['text']
                    submenu_id = f"{button_id}:{b['text']}"
                    inline_kb.append([InlineKeyboardButton(text=b['text'], callback_data=f"dyn:{submenu_id}")])

            # Add Back button if it's a submenu
            if item.get('parent_id'):
                inline_kb.append([InlineKeyboardButton(text="‚¨ÖÔ∏è –ù–∞–∑–∞–¥", callback_data=f"dyn:{item['parent_id']}")])

            reply_markup = InlineKeyboardMarkup(inline_keyboard=inline_kb)
        except Exception as e:
            logger.error(f"Error parsing buttons JSON: {e}")

    # Send content
    text = item['content']
    photo = item['photo_file_id']

    try:
        # For dynamic menus, we always try to edit the message to provide a smooth transition
        if photo:
            # If there's a photo, we use input_media to edit if possible, 
            # or just send new if it's easier to maintain state
            await query.message.answer_photo(photo, caption=text, reply_markup=reply_markup, parse_mode=ParseMode.HTML)
            await query.message.delete()
        else:
            await safe_edit_message(query, text, reply_markup=reply_markup)
    except Exception as e:
        logger.error(f"Error displaying button content: {e}")
        # If edit fails (e.g. message is too old or same content), send as new
        if photo:
            await query.message.answer_photo(photo, caption=text, reply_markup=reply_markup, parse_mode=ParseMode.HTML)
        else:
            await query.message.answer(text, reply_markup=reply_markup, parse_mode=ParseMode.HTML)

@router.message(AdminMenuStates.adding_inline_button_url)
async def add_inline_url(message: types.Message, state: FSMContext):
    data = await state.get_data()
    inline_label = data.get('inline_label')

    if message.text == "–º–µ–Ω—é":
        # Start creating a nested menu item
        # The parent is the current button we are configuring
        # If we are editing a nested button, we might need a better parent tracking
        # For now, let's use the current button label as parent
        await state.update_data(current_parent_id=data.get('editing_button_label') or data.get('label'))
        await state.set_state(AdminMenuStates.creating_nested)
        await message.answer(f"üìù –°–æ–∑–¥–∞–µ–º –≤–ª–æ–∂–µ–Ω–Ω–æ–µ –º–µ–Ω—é –¥–ª—è –∫–Ω–æ–ø–∫–∏ '<b>{inline_label}</b>'.\n\n–í–≤–µ–¥–∏—Ç–µ —Ç–µ–∫—Å—Ç —Å–æ–æ–±—â–µ–Ω–∏—è, –∫–æ—Ç–æ—Ä—ã–π —É–≤–∏–¥–∏—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å:", parse_mode=ParseMode.HTML)
    else:
        # Standard URL button
        inline_buttons = data.get('inline_buttons_list', [])
        inline_buttons.append({"text": inline_label, "url": message.text})
        await state.update_data(inline_buttons_list=inline_buttons)

        await state.set_state(AdminMenuStates.adding_inline_button_text)
        await message.answer(f"‚úÖ –ö–Ω–æ–ø–∫–∞ '<b>{inline_label}</b>' –¥–æ–±–∞–≤–ª–µ–Ω–∞.\n\n–í–≤–µ–¥–∏—Ç–µ —Ç–µ–∫—Å—Ç –¥–ª—è —Å–ª–µ–¥—É—é—â–µ–π –∏–Ω–ª–∞–π–Ω-–∫–Ω–æ–ø–∫–∏ –∏–ª–∏ –Ω–∞–ø–∏—à–∏—Ç–µ '<b>–∑–∞–≤–µ—Ä—à–∏—Ç—å</b>':",
                             reply_markup=ReplyKeyboardMarkup(keyboard=[[KeyboardButton(text="–∑–∞–≤–µ—Ä—à–∏—Ç—å")], [KeyboardButton(text="‚¨ÖÔ∏è –û—Ç–º–µ–Ω–∞")]], resize_keyboard=True),
                             parse_mode=ParseMode.HTML)

@router.message(AdminMenuStates.creating_nested)
async def process_nested_content(message: types.Message, state: FSMContext):
    data = await state.get_data()
    parent_id = data.get('current_parent_id')
    inline_label = data.get('inline_label')

    # Unique ID for nested content
    nested_id = f"{parent_id}:{inline_label}"

    # Support for photo, caption, and HTML formatting
    photo_file_id = message.photo[-1].file_id if message.photo else None
    content = message.caption or message.text if message.photo else message.text

    # Process fonts/formatting - aiogram does this automatically if parse_mode is HTML
    # and the user uses Telegram's built-in formatting.

    # Save the nested content with full support (photo, content)
    await update_button_content(nested_id, content, photo_file_id=photo_file_id, parent_id=parent_id)

    # Add trigger button to parent's list
    inline_buttons = data.get('inline_buttons_list', [])
    inline_buttons.append({"text": inline_label, "url": "–º–µ–Ω—é"})
    await state.update_data(inline_buttons_list=inline_buttons)

    await state.set_state(AdminMenuStates.adding_inline_button_text)
    await message.answer(f"‚úÖ –í–ª–æ–∂–µ–Ω–Ω—ã–π —Ä–∞–∑–¥–µ–ª '<b>{inline_label}</b>' —Å–æ–∑–¥–∞–Ω.\n\n"
                         "–¢–µ–ø–µ—Ä—å –≤—ã –º–æ–∂–µ—Ç–µ:\n"
                         "1. –í–≤–µ—Å—Ç–∏ —Ç–µ–∫—Å—Ç –¥–ª—è —Å–ª–µ–¥—É—é—â–µ–π –∏–Ω–ª–∞–π–Ω-–∫–Ω–æ–ø–∫–∏ (–Ω–∞ —ç—Ç–æ–º –∂–µ —É—Ä–æ–≤–Ω–µ)\n"
                         "2. –ù–∞–ø–∏—Å–∞—Ç—å '<b>–∑–∞–≤–µ—Ä—à–∏—Ç—å</b>', —á—Ç–æ–±—ã —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å –≤—Å—ë –º–µ–Ω—é",
                         reply_markup=ReplyKeyboardMarkup(keyboard=[[KeyboardButton(text="–∑–∞–≤–µ—Ä—à–∏—Ç—å")], [KeyboardButton(text="‚¨ÖÔ∏è –û—Ç–º–µ–Ω–∞")]], resize_keyboard=True),
                         parse_mode=ParseMode.HTML)

async def finalize_creation(message: types.Message, state: FSMContext, data: dict):
    label = data['label']
    content = data['content']
    photo = data.get('photo')
    inline_buttons = data.get('inline_buttons_list', [])

    # –ü–†–ò–ù–£–î–ò–¢–ï–õ–¨–ù–û –¥–æ–±–∞–≤–ª—è–µ–º –∫–Ω–æ–ø–∫—É –≤ keyboard_buttons, —á—Ç–æ–±—ã –æ–Ω–∞ –æ—Ç–æ–±—Ä–∞–∂–∞–ª–∞—Å—å –≤ –º–µ–Ω—é
    print(f"[BOT_DEBUG] Finalizing creation for '{label}'. Adding to keyboard_buttons...")
    await add_keyboard_button(label)

    # –°–æ—Ö—Ä–∞–Ω—è–µ–º –∫–æ–Ω—Ç–µ–Ω—Ç
    await update_button_content(label, content, photo, json.dumps(inline_buttons) if inline_buttons else None)

    await message.answer(f"‚úÖ –ö–Ω–æ–ø–∫–∞ '{label}' —Å–æ–∑–¥–∞–Ω–∞ —Å–æ –≤—Å–µ–º–∏ –ø–æ–¥–º–µ–Ω—é!")
    await manage_menu(message, state)

async def handle_all_text_messages(message: types.Message, state: FSMContext):
    label = message.text
    if not label: return

    print(f"\n[BOT_DEBUG_VERBOSE] === Global Handler Start === Label: '{label}'")

    # 0. –°–Ω–∞—á–∞–ª–∞ –ø—Ä–æ–≤–µ—Ä—è–µ–º —Å–∏—Å—Ç–µ–º–Ω—ã–µ –∫–Ω–æ–ø–∫–∏ –≤–æ–∑–≤—Ä–∞—Ç–∞
    if label in ["üîô –ù–∞–∑–∞–¥", "üîô –ù–∞–∑–∞–¥ –≤ –º–µ–Ω—é", "üîô –í—ã–π—Ç–∏"]:
        print(f"[BOT_DEBUG_VERBOSE] System back button: '{label}'")
        return await cmd_start(message, state)

    # 1. –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏—è FSM (–í–´–°–®–ò–ô –ü–†–ò–û–†–ò–¢–ï–¢ –î–õ–Ø –ê–î–ú–ò–ù–ö–ò)
    current_state = await state.get_state()
    print(f"[BOT_DEBUG_VERBOSE] Current State: {current_state}")
    if current_state:
        state_str = str(current_state)
        # –ï—Å–ª–∏ —Å–æ—Å—Ç–æ—è–Ω–∏–µ —Å–æ–¥–µ—Ä–∂–∏—Ç –∫–ª—é—á–µ–≤—ã–µ —Å–ª–æ–≤–∞ –æ–∂–∏–¥–∞–Ω–∏—è –≤–≤–æ–¥–∞ - –≤—ã—Ö–æ–¥–∏–º, –¥–∞–µ–º —Å—Ä–∞–±–æ—Ç–∞—Ç—å –¥—Ä—É–≥–∏–º —Ö–µ–Ω–¥–ª–µ—Ä–∞–º
        text_expecting_keywords = ["waiting", "adding", "editing", "creating", "confirming", "managing", "main"]
        if any(k in state_str.lower() for k in text_expecting_keywords):
            print(f"[BOT_DEBUG_VERBOSE] State '{state_str}' is active. Letting FSM handler proceed.")
            return

    # 2. –ü—Ä–æ–≤–µ—Ä—è–µ–º –¥–∏–Ω–∞–º–∏—á–µ—Å–∫–∏–µ –∫–Ω–æ–ø–∫–∏ (–ë–î –∏ —Å—Ç–∞—Ç–∏–∫–∞)
    try:
        print(f"[BOT_DEBUG_VERBOSE] Trying handle_dynamic_buttons for '{label}'")
        handled = await handle_dynamic_buttons(message, state)
        if handled:
            print(f"[BOT_DEBUG_VERBOSE] ‚úÖ Handled by handle_dynamic_buttons")
            return
        else:
            print(f"[BOT_DEBUG_VERBOSE] ‚ùå NOT handled by handle_dynamic_buttons: '{label}'")
    except Exception as e:
        print(f"[BOT_DEBUG_VERBOSE] ‚ùå CRITICAL Error in handle_dynamic_buttons: {e}")
        import traceback
        traceback.print_exc()

    # 3. –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å—Ç–∞—Ç–∏—á–µ—Å–∫–∏—Ö –∫–æ–º–∞–Ω–¥
    if label.startswith("/"):
        print(f"[BOT_DEBUG_VERBOSE] Command detected, ignoring fallback.")
        return

    # 4. –ï—Å–ª–∏ –Ω–∏—á–µ–≥–æ –Ω–µ –ø–æ–¥–æ—à–ª–æ, –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –º–µ–Ω—é
    print(f"[BOT_DEBUG_VERBOSE] Fallback: No match for '{label}'. Showing menu.")
    keyboard = await get_dynamic_keyboard(message.from_user.id)
    await message.answer("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–Ω–æ–ø–∫–∏ –º–µ–Ω—é –¥–ª—è –Ω–∞–≤–∏–≥–∞—Ü–∏–∏.", reply_markup=keyboard)

@router.message(AdminMenuStates.managing_menu, F.text == "‚ûï –î–æ–±–∞–≤–∏—Ç—å –∫–Ω–æ–ø–∫—É")
async def add_btn_start(message: types.Message, state: FSMContext):
    await state.set_state(AdminMenuStates.adding_button_label)
    await message.answer("–í–≤–µ–¥–∏—Ç–µ –Ω–∞–∑–≤–∞–Ω–∏–µ –Ω–æ–≤–æ–π –∫–Ω–æ–ø–∫–∏:", reply_markup=ReplyKeyboardMarkup(keyboard=[[KeyboardButton(text="‚¨ÖÔ∏è –û—Ç–º–µ–Ω–∞")]], resize_keyboard=True))

@router.message(AdminMenuStates.adding_button_label)
async def add_btn_finish(message: types.Message, state: FSMContext):
    if message.text == "‚¨ÖÔ∏è –û—Ç–º–µ–Ω–∞": return await manage_menu(message, state)
    label = message.text

    # Check if this button is already in MENU_STRUCTURE (static)
    if label in [m['label'] for m in MENU_STRUCTURE.values()]:
        await message.answer(f"‚ùå –ö–Ω–æ–ø–∫–∞ '{label}' —è–≤–ª—è–µ—Ç—Å—è —Å–∏—Å—Ç–µ–º–Ω–æ–π –∏ –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å —Å–æ–∑–¥–∞–Ω–∞ –∑–∞–Ω–æ–≤–æ.")
        return await manage_menu(message, state)

    await add_keyboard_button(label)
    await update_button_content(label, f"–ö–æ–Ω—Ç–µ–Ω—Ç –¥–ª—è –∫–Ω–æ–ø–∫–∏ {label}")
    await message.answer(f"‚úÖ –ö–Ω–æ–ø–∫–∞ '{label}' –¥–æ–±–∞–≤–ª–µ–Ω–∞.")
    await manage_menu(message, state)

@router.message(AdminMenuStates.managing_menu, F.text == "‚ùå –£–¥–∞–ª–∏—Ç—å –∫–Ω–æ–ø–∫—É")
async def delete_btn_start(message: types.Message, state: FSMContext):
    buttons = await get_all_keyboard_buttons()
    if not buttons:
        await message.answer("–ù–µ—Ç –∫–Ω–æ–ø–æ–∫ –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è.")
        return
    kb = [[KeyboardButton(text=btn['label'])] for btn in buttons]
    kb.append([KeyboardButton(text="‚¨ÖÔ∏è –û—Ç–º–µ–Ω–∞")])
    await message.answer("–í—ã–±–µ—Ä–∏—Ç–µ –∫–Ω–æ–ø–∫—É –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è:", reply_markup=ReplyKeyboardMarkup(keyboard=kb, resize_keyboard=True))

@router.message(AdminMenuStates.managing_menu, F.text == "‚¨ÖÔ∏è –ù–∞–∑–∞–¥")
async def back_to_admin_from_menu(message: types.Message, state: FSMContext):
    await state.clear()
    await admin_button(message, state)

@router.message(F.text == "üìù –†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å –∫–Ω–æ–ø–∫–∏")
async def start_button_edit(message: types.Message, state: FSMContext):
    if message.from_user.id != ADMIN_ID: return

    # Get all buttons (top-level and nested)
    async with pool.acquire() as conn:
        all_items = await conn.fetch('SELECT button_id FROM button_content ORDER BY button_id')

    kb = []
    for item in all_items:
        kb.append([KeyboardButton(text=f"EDIT:{item['button_id']}")])

    kb.append([KeyboardButton(text="‚¨ÖÔ∏è –û—Ç–º–µ–Ω–∞")])
    await state.set_state(ButtonEditStates.selecting_button)
    await message.answer("üìù <b>–†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ —Ç–µ–∫—Å—Ç–æ–≤</b>\n\n–í—ã–±–µ—Ä–∏—Ç–µ –∫–Ω–æ–ø–∫—É –∏–ª–∏ –ø–æ–¥–º–µ–Ω—é –¥–ª—è –∏–∑–º–µ–Ω–µ–Ω–∏—è:", 
                         reply_markup=ReplyKeyboardMarkup(keyboard=kb, resize_keyboard=True),
                         parse_mode=ParseMode.HTML)

@router.message(ButtonEditStates.selecting_button, F.text.startswith("EDIT:"))
async def select_edit(message: types.Message, state: FSMContext):
    label = message.text[5:]
    await state.update_data(editing_button_label=label)
    await state.set_state(ButtonEditStates.waiting_for_content)
    await message.answer(f"–†–µ–¥–∞–∫—Ç–∏—Ä—É–µ–º '{label}'. –í–≤–µ–¥–∏—Ç–µ –Ω–æ–≤—ã–π —Ç–µ–∫—Å—Ç:")

@router.message(ButtonEditStates.selecting_button, F.text.startswith("BTN:"))
async def select_button_for_edit(message: types.Message, state: FSMContext):
    button_label = message.text[4:]
    await state.update_data(editing_button_label=button_label)
    await state.set_state(ButtonEditStates.waiting_for_content)
    await message.answer(f"–í–≤–µ–¥–∏—Ç–µ –Ω–æ–≤—ã–π —Ç–µ–∫—Å—Ç –¥–ª—è –∫–Ω–æ–ø–∫–∏ '{button_label}':\n(–ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è HTML: <b></b>, <i></i>, <a href=''></a>)", 
                         reply_markup=ReplyKeyboardMarkup(keyboard=[[KeyboardButton(text="‚¨ÖÔ∏è –û—Ç–º–µ–Ω–∞")]], resize_keyboard=True))

@router.message(ButtonEditStates.waiting_for_content)
async def process_button_content(message: types.Message, state: FSMContext):
    if message.text == "‚¨ÖÔ∏è –û—Ç–º–µ–Ω–∞":
        await state.clear()
        return await admin_button(message, state)

    await state.update_data(new_content=message.text)
    await state.set_state(ButtonEditStates.waiting_for_photo)
    await message.answer("–û—Ç–ø—Ä–∞–≤—å—Ç–µ —Ñ–æ—Ç–æ –¥–ª—è —ç—Ç–æ–π –∫–Ω–æ–ø–∫–∏ –∏–ª–∏ '–ø—Ä–æ–ø—É—Å—Ç–∏—Ç—å':", 
                         reply_markup=ReplyKeyboardMarkup(keyboard=[[KeyboardButton(text="–ø—Ä–æ–ø—É—Å—Ç–∏—Ç—å")], [KeyboardButton(text="‚¨ÖÔ∏è –û—Ç–º–µ–Ω–∞")]], resize_keyboard=True))

@router.message(ButtonEditStates.waiting_for_photo)
async def process_button_photo(message: types.Message, state: FSMContext):
    photo_id = message.photo[-1].file_id if message.photo else None
    await state.update_data(new_photo=photo_id)
    await state.set_state(ButtonEditStates.waiting_for_inline_buttons)
    await message.answer("–í–≤–µ–¥–∏—Ç–µ –∏–Ω–ª–∞–π–Ω-–∫–Ω–æ–ø–∫–∏ –≤ —Ñ–æ—Ä–º–∞—Ç–µ '–ù–∞–∑–≤–∞–Ω–∏–µ - –°—Å—ã–ª–∫–∞' (–∫–∞–∂–¥–∞—è —Å –Ω–æ–≤–æ–π —Å—Ç—Ä–æ–∫–∏) –∏–ª–∏ '–Ω–µ—Ç':",
                         reply_markup=ReplyKeyboardMarkup(keyboard=[[KeyboardButton(text="–Ω–µ—Ç")], [KeyboardButton(text="‚¨ÖÔ∏è –û—Ç–º–µ–Ω–∞")]], resize_keyboard=True))

@router.message(ButtonEditStates.waiting_for_inline_buttons)
async def save_button_config(message: types.Message, state: FSMContext):
    data = await state.get_data()
    label = data['editing_button_label']
    content = data['new_content']
    photo = data['new_photo']

    inline_buttons = []
    if message.text != "–Ω–µ—Ç":
        for line in message.text.split('\n'):
            if ' - ' in line:
                name, url = line.split(' - ', 1)
                inline_buttons.append({'text': name.strip(), 'url': url.strip()})

    success = await update_button_content(label, content, photo, json.dumps(inline_buttons) if inline_buttons else None)

    if success:
        await message.answer(f"‚úÖ –ö–Ω–æ–ø–∫–∞ '{label}' —É—Å–ø–µ—à–Ω–æ –æ–±–Ω–æ–≤–ª–µ–Ω–∞!")
    else:
        await message.answer(f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏ –∫–Ω–æ–ø–∫–∏ '{label}'.")

    await state.clear()
    await admin_button(message, state)

# ============ –ù–û–í–´–ô –†–ï–î–ê–ö–¢–û–† –ö–û–ù–¢–ï–ù–¢–ê ============

# –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏ –¥–ª—è —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –∏–Ω–ª–∞–π–Ω-–∫–Ω–æ–ø–∫–∞–º–∏
async def delete_inline_button(menu_id: str, button_to_delete: dict) -> bool:
    """–£–¥–∞–ª—è–µ—Ç –∏–Ω–ª–∞–π–Ω-–∫–Ω–æ–ø–∫—É –∏–∑ –º–µ–Ω—é"""
    try:
        # –û–ø—Ä–µ–¥–µ–ª—è–µ–º button_label
        if menu_id.startswith('db:'):
            button_label = menu_id[3:]
        elif menu_id.startswith('static:'):
            button_label = menu_id[7:]
        else:
            return False

        # –ü–æ–ª—É—á–∞–µ–º –∫–æ–Ω—Ç–µ–Ω—Ç –∏–∑ –ë–î
        db_content = await get_button_content(button_label)

        # –ï—Å–ª–∏ –∫–æ–Ω—Ç–µ–Ω—Ç–∞ –Ω–µ—Ç –∏ —ç—Ç–æ —Å—Ç–∞—Ç–∏—á–µ—Å–∫–æ–µ –º–µ–Ω—é - —Å–æ–∑–¥–∞–µ–º –∑–∞–ø–∏—Å—å
        if not db_content and menu_id.startswith('static:'):
            parts = button_label.split(':')
            menu_key = parts[0]
            sub_key = parts[1] if len(parts) > 1 else None

            if sub_key and menu_key in MENU_STRUCTURE and sub_key in MENU_STRUCTURE[menu_key].get('submenu', {}):
                menu_data = MENU_STRUCTURE[menu_key]['submenu'][sub_key]
            elif menu_key in MENU_STRUCTURE:
                menu_data = MENU_STRUCTURE[menu_key]
            else:
                return False

            # –°–æ–∑–¥–∞–µ–º –∑–∞–ø–∏—Å—å
            await update_button_content(button_label, menu_data.get('text', ''), None, None, 'HTML', None)
            db_content = await get_button_content(button_label)

        if not db_content:
            return False

        # –ü–æ–ª—É—á–∞–µ–º —Ç–µ–∫—É—â–∏–µ –∫–Ω–æ–ø–∫–∏
        buttons = []
        if db_content.get('buttons_json'):
            try:
                buttons = json.loads(db_content['buttons_json'])
            except:
                pass

        # –£–¥–∞–ª—è–µ–º –∫–Ω–æ–ø–∫—É
        if button_to_delete['source'] == 'db':
            # –£–¥–∞–ª—è–µ–º –∏–∑ —Å–ø–∏—Å–∫–∞ –∫–Ω–æ–ø–æ–∫ –≤ –ë–î
            buttons = [b for b in buttons if b.get('text') != button_to_delete['text']]
        else:
            # –î–ª—è —Å—Ç–∞—Ç–∏—á–µ—Å–∫–∏—Ö –∫–Ω–æ–ø–æ–∫ –Ω–∏—á–µ–≥–æ –Ω–µ –¥–µ–ª–∞–µ–º - –æ–Ω–∏ –Ω–µ —É–¥–∞–ª—è—é—Ç—Å—è –∏–∑ MENU_STRUCTURE
            # –ù–æ –º–æ–∂–Ω–æ –ø–æ–º–µ—Ç–∏—Ç—å –∏—Ö –∫–∞–∫ —Å–∫—Ä—ã—Ç—ã–µ –≤ –ë–î (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ)
            return False  # –ü–æ–∫–∞ –Ω–µ —Ä–∞–∑—Ä–µ—à–∞–µ–º —É–¥–∞–ª—è—Ç—å —Å—Ç–∞—Ç–∏—á–µ—Å–∫–∏–µ –∫–Ω–æ–ø–∫–∏

        # –°–æ—Ö—Ä–∞–Ω—è–µ–º –æ–±–Ω–æ–≤–ª–µ–Ω–Ω—ã–π —Å–ø–∏—Å–æ–∫
        success = await update_button_content(
            button_label,
            db_content.get('content'),
            db_content.get('photo_file_id'),
            json.dumps(buttons) if buttons else None,
            db_content.get('parse_mode', 'HTML'),
            db_content.get('parent_id')
        )

        return success
    except Exception as e:
        print(f"Error deleting inline button: {e}")
        return False

async def rename_inline_button(menu_id: str, button_to_rename: dict, new_name: str) -> bool:
    """–ü–µ—Ä–µ–∏–º–µ–Ω–æ–≤—ã–≤–∞–µ—Ç –∏–Ω–ª–∞–π–Ω-–∫–Ω–æ–ø–∫—É"""
    try:
        # –û–ø—Ä–µ–¥–µ–ª—è–µ–º button_label
        if menu_id.startswith('db:'):
            button_label = menu_id[3:]
        elif menu_id.startswith('static:'):
            button_label = menu_id[7:]
        else:
            return False

        # –ü–æ–ª—É—á–∞–µ–º –∫–æ–Ω—Ç–µ–Ω—Ç –∏–∑ –ë–î
        db_content = await get_button_content(button_label)

        # –ï—Å–ª–∏ –∫–æ–Ω—Ç–µ–Ω—Ç–∞ –Ω–µ—Ç –∏ —ç—Ç–æ —Å—Ç–∞—Ç–∏—á–µ—Å–∫–æ–µ –º–µ–Ω—é - —Å–æ–∑–¥–∞–µ–º –∑–∞–ø–∏—Å—å
        if not db_content and menu_id.startswith('static:'):
            parts = button_label.split(':')
            menu_key = parts[0]
            sub_key = parts[1] if len(parts) > 1 else None

            if sub_key and menu_key in MENU_STRUCTURE and sub_key in MENU_STRUCTURE[menu_key].get('submenu', {}):
                menu_data = MENU_STRUCTURE[menu_key]['submenu'][sub_key]
            elif menu_key in MENU_STRUCTURE:
                menu_data = MENU_STRUCTURE[menu_key]
            else:
                return False

            # –°–æ–∑–¥–∞–µ–º –∑–∞–ø–∏—Å—å
            await update_button_content(button_label, menu_data.get('text', ''), None, None, 'HTML', None)
            db_content = await get_button_content(button_label)

        if not db_content:
            return False

        # –ü–æ–ª—É—á–∞–µ–º —Ç–µ–∫—É—â–∏–µ –∫–Ω–æ–ø–∫–∏
        buttons = []
        if db_content.get('buttons_json'):
            try:
                buttons = json.loads(db_content['buttons_json'])
            except:
                pass

        # –ü–µ—Ä–µ–∏–º–µ–Ω–æ–≤—ã–≤–∞–µ–º –∫–Ω–æ–ø–∫—É
        if button_to_rename['source'] == 'db':
            # –ò—â–µ–º –∏ –ø–µ—Ä–µ–∏–º–µ–Ω–æ–≤—ã–≤–∞–µ–º –≤ —Å–ø–∏—Å–∫–µ –∫–Ω–æ–ø–æ–∫ –ë–î
            for b in buttons:
                if b.get('text') == button_to_rename['text']:
                    b['text'] = new_name
                    break
        else:
            # –î–ª—è —Å—Ç–∞—Ç–∏—á–µ—Å–∫–∏—Ö –∫–Ω–æ–ø–æ–∫ - –ø–æ–∫–∞ –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º
            # –¢–∞–∫ –∫–∞–∫ –æ–Ω–∏ –≤ MENU_STRUCTURE –∏ —Ç—Ä–µ–±—É—é—Ç –∏–∑–º–µ–Ω–µ–Ω–∏—è –∫–æ–¥–∞
            return False

        # –°–æ—Ö—Ä–∞–Ω—è–µ–º –æ–±–Ω–æ–≤–ª–µ–Ω–Ω—ã–π —Å–ø–∏—Å–æ–∫
        success = await update_button_content(
            button_label,
            db_content.get('content'),
            db_content.get('photo_file_id'),
            json.dumps(buttons) if buttons else None,
            db_content.get('parse_mode', 'HTML'),
            db_content.get('parent_id')
        )

        return success
    except Exception as e:
        print(f"Error renaming inline button: {e}")
        return False

@router.message(F.text == "‚úèÔ∏è –†–µ–¥–∞–∫—Ç–æ—Ä –∫–æ–Ω—Ç–µ–Ω—Ç–∞")
async def content_editor_start(message: types.Message, state: FSMContext):
    """–ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é —Ä–µ–¥–∞–∫—Ç–æ—Ä–∞ –∫–æ–Ω—Ç–µ–Ω—Ç–∞"""
    if message.from_user.id != ADMIN_ID:
        return

    # –°–æ–±–∏—Ä–∞–µ–º –í–°–ï –∫–Ω–æ–ø–∫–∏: —Å—Ç–∞—Ç–∏—á–µ—Å–∫–∏–µ –∏–∑ MENU_STRUCTURE + –¥–∏–Ω–∞–º–∏—á–µ—Å–∫–∏–µ –∏–∑ –ë–î
    all_menus = []

    # 1. –°—Ç–∞—Ç–∏—á–µ—Å–∫–∏–µ –∫–Ω–æ–ø–∫–∏ –∏–∑ MENU_STRUCTURE
    for menu_key, menu_data in MENU_STRUCTURE.items():
        label = menu_data.get('label', menu_key)
        all_menus.append({
            'id': f'static:{menu_key}',
            'label': label,
            'type': 'static'
        })
        # –î–æ–±–∞–≤–ª—è–µ–º –ø–æ–¥–º–µ–Ω—é –µ—Å–ª–∏ –µ—Å—Ç—å
        if 'submenu' in menu_data:
            for sub_key, sub_data in menu_data['submenu'].items():
                sub_label = sub_data.get('label', sub_key)
                all_menus.append({
                    'id': f'static:{menu_key}:{sub_key}',
                    'label': f"  ‚Ü≥ {sub_label}",
                    'type': 'static'
                })

    # 2. –î–∏–Ω–∞–º–∏—á–µ—Å–∫–∏–µ –∫–Ω–æ–ø–∫–∏ –∏–∑ –ë–î
    db_buttons = await get_all_keyboard_buttons()
    for btn in db_buttons:
        label = btn.get('label') or btn['label'] if isinstance(btn, dict) else str(btn)
        all_menus.append({
            'id': f'db:{label}',
            'label': f"üîπ {label}",
            'type': 'db'
        })

    # –°–æ–∑–¥–∞–µ–º –∫–ª–∞–≤–∏–∞—Ç—É—Ä—É
    kb = []
    for menu in all_menus:
        kb.append([KeyboardButton(text=f"EDIT:{menu['id']}")])

    kb.append([KeyboardButton(text="‚¨ÖÔ∏è –ù–∞–∑–∞–¥")])

    await state.set_state(ContentEditorStates.selecting_menu)
    await message.answer(
        "‚úèÔ∏è <b>–†–µ–¥–∞–∫—Ç–æ—Ä –∫–æ–Ω—Ç–µ–Ω—Ç–∞</b>\n\n"
        "–í—ã–±–µ—Ä–∏—Ç–µ —Ä–∞–∑–¥–µ–ª –¥–ª—è —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è:\n"
        "üìå –°—Ç–∞—Ç–∏—á–µ—Å–∫–∏–µ —Ä–∞–∑–¥–µ–ª—ã –∏–∑ –º–µ–Ω—é\n"
        "üîπ –ö–Ω–æ–ø–∫–∏ –∏–∑ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö",
        reply_markup=ReplyKeyboardMarkup(keyboard=kb, resize_keyboard=True),
        parse_mode=ParseMode.HTML
    )

@router.message(ContentEditorStates.selecting_menu, F.text.startswith("EDIT:"))
async def content_editor_select(message: types.Message, state: FSMContext):
    """–û–±—Ä–∞–±–æ—Ç–∫–∞ –≤—ã–±–æ—Ä–∞ –º–µ–Ω—é –¥–ª—è —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è"""
    menu_id = message.text[5:]  # –£–±–∏—Ä–∞–µ–º "EDIT:"

    await state.update_data(editing_menu_id=menu_id)

    # –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Ç–∏–ø –∏ –ø–æ–ª—É—á–∞–µ–º –¥–∞–Ω–Ω—ã–µ
    if menu_id.startswith('static:'):
        # –°—Ç–∞—Ç–∏—á–µ—Å–∫–æ–µ –º–µ–Ω—é
        parts = menu_id[7:].split(':')
        menu_key = parts[0]
        sub_key = parts[1] if len(parts) > 1 else None

        if sub_key:
            menu_data = MENU_STRUCTURE[menu_key]['submenu'][sub_key]
        else:
            menu_data = MENU_STRUCTURE[menu_key]

        current_text = menu_data.get('text', '–ù–µ—Ç —Ç–µ–∫—Å—Ç–∞')
        current_label = menu_data.get('label', menu_key)

        # –ü–æ–ª—É—á–∞–µ–º –∏–Ω–ª–∞–π–Ω-–∫–Ω–æ–ø–∫–∏ - –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –û–ë–ï –≥—Ä—É–ø–ø—ã (–∏–∑ MENU_STRUCTURE –∏ –∏–∑ –ë–î)
        inline_buttons_info = ""
        button_label = menu_id[7:]  # –£–±–∏—Ä–∞–µ–º 'static:'

        # –°–æ–±–∏—Ä–∞–µ–º –≤—Å–µ –∫–Ω–æ–ø–∫–∏ –≤ –æ–¥–∏–Ω —Å–ø–∏—Å–æ–∫
        all_buttons = []
        button_counter = 0

        # 1. –ö–Ω–æ–ø–∫–∏ –∏–∑ MENU_STRUCTURE
        if 'submenu' in menu_data:
            for btn_key, btn_data in menu_data['submenu'].items():
                btn_label = btn_data.get('label', btn_key)
                btn_type = "üìÑ –º–µ–Ω—é" if 'text' in btn_data or 'submenu' in btn_data else "üîó —Å—Å—ã–ª–∫–∞"
                button_counter += 1
                all_buttons.append({
                    'index': button_counter,
                    'text': btn_label,
                    'type': btn_type,
                    'source': 'static',
                    'goto': f"static:{menu_key}:{btn_key}",
                    'key': btn_key
                })
        elif menu_data.get('buttons'):
            for btn in menu_data['buttons']:
                button_counter += 1
                all_buttons.append({
                    'index': button_counter,
                    'text': btn['text'],
                    'type': 'üîó callback',
                    'source': 'static',
                    'callback': btn.get('callback', 'callback')
                })

        # 2. –ö–Ω–æ–ø–∫–∏ –∏–∑ –ë–î
        db_content = await get_button_content(button_label)
        if db_content and db_content.get('buttons_json'):
            try:
                buttons = json.loads(db_content['buttons_json'])
                for btn in buttons:
                    button_counter += 1
                    if btn.get('url'):
                        all_buttons.append({
                            'index': button_counter,
                            'text': btn['text'],
                            'type': 'üîó URL',
                            'source': 'db',
                            'url': btn['url']
                        })
                    else:
                        submenu_id = btn.get('id', f"{button_label}:{btn['text']}")
                        all_buttons.append({
                            'index': button_counter,
                            'text': btn['text'],
                            'type': 'üìÑ –º–µ–Ω—é',
                            'source': 'db',
                            'goto': f"db:{submenu_id}",
                            'id': submenu_id
                        })
            except:
                pass

        # –§–æ—Ä–º–∏—Ä—É–µ–º —Ç–µ–∫—Å—Ç —Å –∫–Ω–æ–ø–∫–∞–º–∏
        if all_buttons:
            inline_buttons_info = "\n\n<b>üìã –ò–Ω–ª–∞–π–Ω-–∫–Ω–æ–ø–∫–∏:</b>\n"
            for btn in all_buttons:
                source_label = " (—Å—Ç–∞—Ç–∏–∫–∞)" if btn['source'] == 'static' else " (–ë–î)"
                inline_buttons_info += f"{btn['index']}. {btn['text']} ‚Üí {btn['type']}{source_label}\n"
                if btn.get('goto'):
                    inline_buttons_info += f"   <code>GOTO:{btn['goto']}</code>\n"
                elif btn.get('url'):
                    inline_buttons_info += f"   {btn['url']}\n"
                elif btn.get('callback'):
                    inline_buttons_info += f"   {btn['callback']}\n"

        # –°–æ—Ö—Ä–∞–Ω—è–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –∫–Ω–æ–ø–∫–∞—Ö –≤ state –¥–ª—è –¥–∞–ª—å–Ω–µ–π—à–µ–≥–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è
        await state.update_data(all_inline_buttons=all_buttons)

        # –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –º–µ–Ω—é —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è
        kb = [
            [KeyboardButton(text="üìù –ò–∑–º–µ–Ω–∏—Ç—å —Ç–µ–∫—Å—Ç")],
            [KeyboardButton(text="‚ûï –î–æ–±–∞–≤–∏—Ç—å –∏–Ω–ª–∞–π–Ω-–∫–Ω–æ–ø–∫—É")],
        ]
        if all_buttons:
            kb.append([KeyboardButton(text="üîò –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –∏–Ω–ª–∞–π–Ω-–∫–Ω–æ–ø–∫–∞–º–∏")])
        kb.append([KeyboardButton(text="‚¨ÖÔ∏è –ù–∞–∑–∞–¥")])

        text_preview = current_text[:300] + "..." if len(current_text) > 300 else current_text

        await message.answer(
            f"‚úèÔ∏è <b>–†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ: {current_label}</b>\n\n"
            f"<b>üìÑ –¢–µ–∫—É—â–∏–π —Ç–µ–∫—Å—Ç:</b>\n{text_preview}"
            f"{inline_buttons_info}\n\n"
            f"üí° –ß—Ç–æ–±—ã –æ—Ç–∫—Ä—ã—Ç—å –∏–Ω–ª–∞–π–Ω-–∫–Ω–æ–ø–∫—É, —Å–∫–æ–ø–∏—Ä—É–π—Ç–µ –∫–æ–¥ <code>GOTO:...</code>",
            reply_markup=ReplyKeyboardMarkup(keyboard=kb, resize_keyboard=True),
            parse_mode=ParseMode.HTML
        )

    elif menu_id.startswith('db:'):
        # –ö–Ω–æ–ø–∫–∞ –∏–∑ –ë–î
        button_label = menu_id[3:]
        db_content = await get_button_content(button_label)

        if db_content:
            current_text = db_content.get('content', '–ù–µ—Ç —Ç–µ–∫—Å—Ç–∞')

            # –ü–æ–ª—É—á–∞–µ–º –∏–Ω–ª–∞–π–Ω-–∫–Ω–æ–ø–∫–∏ –∏ —Ñ–æ—Ä–º–∏—Ä—É–µ–º —Å–ø–∏—Å–æ–∫
            inline_buttons_info = ""
            all_buttons = []
            if db_content.get('buttons_json'):
                try:
                    buttons = json.loads(db_content['buttons_json'])
                    inline_buttons_info = "\n\n<b>üìã –ò–Ω–ª–∞–π–Ω-–∫–Ω–æ–ø–∫–∏:</b>\n"
                    for idx, btn in enumerate(buttons, 1):
                        if btn.get('url'):
                            inline_buttons_info += f"{idx}. {btn['text']} ‚Üí üîó URL (–ë–î)\n"
                            inline_buttons_info += f"   {btn['url']}\n"
                            all_buttons.append({
                                'index': idx,
                                'text': btn['text'],
                                'type': 'üîó URL',
                                'source': 'db',
                                'url': btn['url']
                            })
                        else:
                            submenu_id = btn.get('id', f"{button_label}:{btn['text']}")
                            inline_buttons_info += f"{idx}. {btn['text']} ‚Üí üìÑ –º–µ–Ω—é (–ë–î)\n"
                            inline_buttons_info += f"   <code>GOTO:db:{submenu_id}</code>\n"
                            all_buttons.append({
                                'index': idx,
                                'text': btn['text'],
                                'type': 'üìÑ –º–µ–Ω—é',
                                'source': 'db',
                                'goto': f"db:{submenu_id}",
                                'id': submenu_id
                            })
                except:
                    pass

            # –°–æ—Ö—Ä–∞–Ω—è–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –∫–Ω–æ–ø–∫–∞—Ö
            await state.update_data(all_inline_buttons=all_buttons)

            kb = [
                [KeyboardButton(text="üìù –ò–∑–º–µ–Ω–∏—Ç—å —Ç–µ–∫—Å—Ç")],
                [KeyboardButton(text="üñº –ò–∑–º–µ–Ω–∏—Ç—å —Ñ–æ—Ç–æ")],
                [KeyboardButton(text="‚ûï –î–æ–±–∞–≤–∏—Ç—å –∏–Ω–ª–∞–π–Ω-–∫–Ω–æ–ø–∫—É")],
            ]
            if all_buttons:
                kb.append([KeyboardButton(text="üîò –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –∏–Ω–ª–∞–π–Ω-–∫–Ω–æ–ø–∫–∞–º–∏")])
            kb.append([KeyboardButton(text="‚¨ÖÔ∏è –ù–∞–∑–∞–¥")])

            text_preview = current_text[:300] + "..." if len(current_text) > 300 else current_text

            await message.answer(
                f"‚úèÔ∏è <b>–†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ: {button_label}</b>\n\n"
                f"<b>üìÑ –¢–µ–∫—É—â–∏–π —Ç–µ–∫—Å—Ç:</b>\n{text_preview}"
                f"{inline_buttons_info}\n\n"
                f"üí° –ß—Ç–æ–±—ã –æ—Ç–∫—Ä—ã—Ç—å –∏–Ω–ª–∞–π–Ω-–∫–Ω–æ–ø–∫—É, —Å–∫–æ–ø–∏—Ä—É–π—Ç–µ –∫–æ–¥ <code>GOTO:...</code>",
                reply_markup=ReplyKeyboardMarkup(keyboard=kb, resize_keyboard=True),
                parse_mode=ParseMode.HTML
            )
        else:
            await message.answer("‚ùå –ö–æ–Ω—Ç–µ–Ω—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω –≤ –ë–î")
            return await content_editor_start(message, state)

# –û–±—Ä–∞–±–æ—Ç–∫–∞ –ø–µ—Ä–µ—Ö–æ–¥–∞ –∫ –≤–ª–æ–∂–µ–Ω–Ω–æ–º—É –º–µ–Ω—é –ø–æ GOTO:
@router.message(ContentEditorStates.selecting_menu, F.text.startswith("GOTO:"))
async def content_editor_goto_submenu(message: types.Message, state: FSMContext):
    """–ü–µ—Ä–µ—Ö–æ–¥ –∫ —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—é –≤–ª–æ–∂–µ–Ω–Ω–æ–≥–æ –º–µ–Ω—é"""
    goto_path = message.text[5:]  # –£–±–∏—Ä–∞–µ–º "GOTO:"

    # –°–∏–º—É–ª–∏—Ä—É–µ–º –≤—ã–±–æ—Ä —ç—Ç–æ–≥–æ –º–µ–Ω—é
    fake_msg = message.model_copy()
    fake_msg.text = f"EDIT:{goto_path}"

    await content_editor_select(fake_msg, state)

@router.message(ContentEditorStates.selecting_menu, F.text == "üìù –ò–∑–º–µ–Ω–∏—Ç—å —Ç–µ–∫—Å—Ç")
async def content_editor_edit_text(message: types.Message, state: FSMContext):
    """–ù–∞—á–∞–ª–æ —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è —Ç–µ–∫—Å—Ç–∞"""
    await state.set_state(ContentEditorStates.editing_text)
    await message.answer(
        "‚úèÔ∏è <b>–†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ —Ç–µ–∫—Å—Ç–∞</b>\n\n"
        "–í–≤–µ–¥–∏—Ç–µ –Ω–æ–≤—ã–π —Ç–µ–∫—Å—Ç. –ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è HTML —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ:\n"
        "‚Ä¢ <code>&lt;b&gt;–∂–∏—Ä–Ω—ã–π&lt;/b&gt;</code> ‚Üí <b>–∂–∏—Ä–Ω—ã–π</b>\n"
        "‚Ä¢ <code>&lt;i&gt;–∫—É—Ä—Å–∏–≤&lt;/i&gt;</code> ‚Üí <i>–∫—É—Ä—Å–∏–≤</i>\n"
        "‚Ä¢ <code>&lt;a href='URL'&gt;—Ç–µ–∫—Å—Ç&lt;/a&gt;</code> ‚Üí —Å—Å—ã–ª–∫–∞\n"
        "‚Ä¢ <code>&lt;code&gt;–∫–æ–¥&lt;/code&gt;</code> ‚Üí <code>–∫–æ–¥</code>",
        reply_markup=ReplyKeyboardMarkup(
            keyboard=[[KeyboardButton(text="‚¨ÖÔ∏è –û—Ç–º–µ–Ω–∞")]],
            resize_keyboard=True
        ),
        parse_mode=ParseMode.HTML
    )

@router.message(ContentEditorStates.editing_text)
async def content_editor_save_text(message: types.Message, state: FSMContext):
    """–°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –Ω–æ–≤–æ–≥–æ —Ç–µ–∫—Å—Ç–∞"""
    if message.text == "‚¨ÖÔ∏è –û—Ç–º–µ–Ω–∞":
        await state.clear()
        return await content_editor_start(message, state)

    data = await state.get_data()
    menu_id = data.get('editing_menu_id')
    new_text = message.text

    if menu_id.startswith('db:'):
        # –û–±–Ω–æ–≤–ª—è–µ–º –≤ –ë–î
        button_label = menu_id[3:]
        db_content = await get_button_content(button_label)

        if db_content:
            success = await update_button_content(
                button_label,
                new_text,
                db_content.get('photo_file_id'),
                db_content.get('buttons_json'),
                db_content.get('parse_mode', 'HTML'),
                db_content.get('parent_id')
            )

            if success:
                await message.answer("‚úÖ –¢–µ–∫—Å—Ç —É—Å–ø–µ—à–Ω–æ –æ–±–Ω–æ–≤–ª–µ–Ω!")
            else:
                await message.answer("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏")
        else:
            # –°–æ–∑–¥–∞–µ–º –Ω–æ–≤—ã–π –∫–æ–Ω—Ç–µ–Ω—Ç
            success = await update_button_content(button_label, new_text)
            if success:
                await message.answer("‚úÖ –ö–æ–Ω—Ç–µ–Ω—Ç —Å–æ–∑–¥–∞–Ω!")
            else:
                await message.answer("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏")
    else:
        await message.answer(
            "‚ö†Ô∏è <b>–í–∞–∂–Ω–æ!</b>\n\n"
            "–°—Ç–∞—Ç–∏—á–µ—Å–∫–∏–µ –º–µ–Ω—é —Ä–µ–¥–∞–∫—Ç–∏—Ä—É—é—Ç—Å—è –≤ –∫–æ–¥–µ (MENU_STRUCTURE).\n"
            "–î–ª—è –ø–æ—Å—Ç–æ—è–Ω–Ω–æ–≥–æ –∏–∑–º–µ–Ω–µ–Ω–∏—è –æ–±—Ä–∞—Ç–∏—Ç–µ—Å—å –∫ —Ä–∞–∑—Ä–∞–±–æ—Ç—á–∏–∫—É.\n\n"
            "–í—ã –º–æ–∂–µ—Ç–µ —Å–æ–∑–¥–∞—Ç—å –¥–∏–Ω–∞–º–∏—á–µ—Å–∫—É—é –≤–µ—Ä—Å–∏—é —ç—Ç–æ–≥–æ –º–µ–Ω—é –≤ –ë–î.",
            parse_mode=ParseMode.HTML
        )

    await state.clear()
    await admin_button(message, state)

@router.message(ContentEditorStates.selecting_menu, F.text == "‚ûï –î–æ–±–∞–≤–∏—Ç—å –∏–Ω–ª–∞–π–Ω-–∫–Ω–æ–ø–∫—É")
async def content_editor_add_inline_button_start(message: types.Message, state: FSMContext):
    """–ù–∞—á–∞–ª–æ –¥–æ–±–∞–≤–ª–µ–Ω–∏—è –Ω–æ–≤–æ–π –∏–Ω–ª–∞–π–Ω-–∫–Ω–æ–ø–∫–∏"""
    kb = [
        [KeyboardButton(text="üîó –ö–Ω–æ–ø–∫–∞-—Å—Å—ã–ª–∫–∞ (URL)")],
        [KeyboardButton(text="üìÑ –ö–Ω–æ–ø–∫–∞-–º–µ–Ω—é (submenu)")],
        [KeyboardButton(text="‚¨ÖÔ∏è –û—Ç–º–µ–Ω–∞")]
    ]

    await state.set_state(ContentEditorStates.adding_inline_button)
    await message.answer(
        "‚ûï <b>–î–æ–±–∞–≤–ª–µ–Ω–∏–µ –∏–Ω–ª–∞–π–Ω-–∫–Ω–æ–ø–∫–∏</b>\n\n"
        "–í—ã–±–µ—Ä–∏—Ç–µ —Ç–∏–ø –∫–Ω–æ–ø–∫–∏:\n"
        "‚Ä¢ üîó <b>–ö–Ω–æ–ø–∫–∞-—Å—Å—ã–ª–∫–∞</b> - –æ—Ç–∫—Ä—ã–≤–∞–µ—Ç URL\n"
        "‚Ä¢ üìÑ <b>–ö–Ω–æ–ø–∫–∞-–º–µ–Ω—é</b> - –æ—Ç–∫—Ä—ã–≤–∞–µ—Ç —Ç–µ–∫—Å—Ç —Å –Ω–æ–≤—ã–º–∏ –∫–Ω–æ–ø–∫–∞–º–∏",
        reply_markup=ReplyKeyboardMarkup(keyboard=kb, resize_keyboard=True),
        parse_mode=ParseMode.HTML
    )

@router.message(ContentEditorStates.adding_inline_button, F.text == "üîó –ö–Ω–æ–ø–∫–∞-—Å—Å—ã–ª–∫–∞ (URL)")
async def content_editor_add_url_button(message: types.Message, state: FSMContext):
    """–î–æ–±–∞–≤–ª–µ–Ω–∏–µ –∫–Ω–æ–ø–∫–∏-—Å—Å—ã–ª–∫–∏"""
    await state.update_data(button_type='url')
    await state.set_state(ContentEditorStates.waiting_button_text)
    await message.answer(
        "–í–≤–µ–¥–∏—Ç–µ —Ç–µ–∫—Å—Ç –¥–ª—è –∫–Ω–æ–ø–∫–∏:",
        reply_markup=ReplyKeyboardMarkup(
            keyboard=[[KeyboardButton(text="‚¨ÖÔ∏è –û—Ç–º–µ–Ω–∞")]],
            resize_keyboard=True
        )
    )

@router.message(ContentEditorStates.adding_inline_button, F.text == "üìÑ –ö–Ω–æ–ø–∫–∞-–º–µ–Ω—é (submenu)")
async def content_editor_add_menu_button(message: types.Message, state: FSMContext):
    """–î–æ–±–∞–≤–ª–µ–Ω–∏–µ –∫–Ω–æ–ø–∫–∏-–º–µ–Ω—é"""
    await state.update_data(button_type='menu')
    await state.set_state(ContentEditorStates.waiting_button_text)
    await message.answer(
        "–í–≤–µ–¥–∏—Ç–µ —Ç–µ–∫—Å—Ç –¥–ª—è –∫–Ω–æ–ø–∫–∏:",
        reply_markup=ReplyKeyboardMarkup(
            keyboard=[[KeyboardButton(text="‚¨ÖÔ∏è –û—Ç–º–µ–Ω–∞")]],
            resize_keyboard=True
        )
    )

@router.message(ContentEditorStates.waiting_button_text)
async def content_editor_button_text_received(message: types.Message, state: FSMContext):
    """–ü–æ–ª—É—á–µ–Ω —Ç–µ–∫—Å—Ç –∫–Ω–æ–ø–∫–∏"""
    if message.text == "‚¨ÖÔ∏è –û—Ç–º–µ–Ω–∞":
        await state.set_state(ContentEditorStates.selecting_menu)
        return await content_editor_start(message, state)

    await state.update_data(button_text=message.text)
    data = await state.get_data()
    button_type = data.get('button_type')

    if button_type == 'url':
        await state.set_state(ContentEditorStates.waiting_button_url)
        await message.answer(
            f"‚úèÔ∏è –¢–µ–∫—Å—Ç –∫–Ω–æ–ø–∫–∏: <b>{message.text}</b>\n\n"
            f"–¢–µ–ø–µ—Ä—å –≤–≤–µ–¥–∏—Ç–µ URL (—Å—Å—ã–ª–∫—É):",
            reply_markup=ReplyKeyboardMarkup(
                keyboard=[[KeyboardButton(text="‚¨ÖÔ∏è –û—Ç–º–µ–Ω–∞")]],
                resize_keyboard=True
            ),
            parse_mode=ParseMode.HTML
        )
    else:  # menu
        # –î–ª—è –∫–Ω–æ–ø–∫–∏-–º–µ–Ω—é —Å—Ä–∞–∑—É —Å–æ–∑–¥–∞–µ–º –∫–æ–Ω—Ç–µ–Ω—Ç
        data = await state.get_data()
        menu_id = data.get('editing_menu_id')
        button_text = data.get('button_text')

        # –û–ø—Ä–µ–¥–µ–ª—è–µ–º button_label –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç —Ç–∏–ø–∞ –º–µ–Ω—é
        if menu_id.startswith('db:'):
            button_label = menu_id[3:]
        elif menu_id.startswith('static:'):
            # –î–ª—è —Å—Ç–∞—Ç–∏—á–µ—Å–∫–æ–≥–æ –º–µ–Ω—é –∏—Å–ø–æ–ª—å–∑—É–µ–º –ø—É—Ç—å –±–µ–∑ –ø—Ä–µ—Ñ–∏–∫—Å–∞ 'static:'
            button_label = menu_id[7:]
        else:
            await message.answer("‚ùå –ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π —Ç–∏–ø –º–µ–Ω—é")
            await state.clear()
            await admin_button(message, state)
            return

        # –ü–æ–ª—É—á–∞–µ–º –∏–ª–∏ —Å–æ–∑–¥–∞–µ–º –∫–æ–Ω—Ç–µ–Ω—Ç –≤ –ë–î
        db_content = await get_button_content(button_label)

        # –ï—Å–ª–∏ –∫–æ–Ω—Ç–µ–Ω—Ç–∞ –Ω–µ—Ç (–¥–ª—è —Å—Ç–∞—Ç–∏—á–µ—Å–∫–∏—Ö –º–µ–Ω—é), —Å–æ–∑–¥–∞–µ–º –∑–∞–ø–∏—Å—å
        if not db_content and menu_id.startswith('static:'):
            # –ü–æ–ª—É—á–∞–µ–º —Ç–µ–∫—Å—Ç –∏–∑ MENU_STRUCTURE
            parts = button_label.split(':')
            menu_key = parts[0]
            sub_key = parts[1] if len(parts) > 1 else None

            if sub_key and menu_key in MENU_STRUCTURE and sub_key in MENU_STRUCTURE[menu_key].get('submenu', {}):
                menu_data = MENU_STRUCTURE[menu_key]['submenu'][sub_key]
            elif menu_key in MENU_STRUCTURE:
                menu_data = MENU_STRUCTURE[menu_key]
            else:
                await message.answer("‚ùå –ú–µ–Ω—é –Ω–µ –Ω–∞–π–¥–µ–Ω–æ")
                await state.clear()
                await admin_button(message, state)
                return

            # –°–æ–∑–¥–∞–µ–º –∑–∞–ø–∏—Å—å –≤ –ë–î —Å —Ç–µ–∫—Å—Ç–æ–º –∏–∑ MENU_STRUCTURE
            await update_button_content(
                button_label,
                menu_data.get('text', ''),
                None,
                None,
                'HTML',
                None
            )
            # –ü–æ–ª—É—á–∞–µ–º —Å–æ–∑–¥–∞–Ω–Ω—ã–π –∫–æ–Ω—Ç–µ–Ω—Ç
            db_content = await get_button_content(button_label)

        if db_content:
            # –ü–æ–ª—É—á–∞–µ–º —Ç–µ–∫—É—â–∏–µ –∫–Ω–æ–ø–∫–∏
            try:
                buttons = json.loads(db_content['buttons_json']) if db_content.get('buttons_json') else []
            except:
                buttons = []

            # –°–æ–∑–¥–∞–µ–º ID –¥–ª—è –Ω–æ–≤–æ–≥–æ –ø–æ–¥–º–µ–Ω—é
            submenu_id = f"{button_label}:{button_text}"

            # –î–æ–±–∞–≤–ª—è–µ–º –Ω–æ–≤—É—é –∫–Ω–æ–ø–∫—É
            buttons.append({
                'text': button_text,
                'id': submenu_id
            })

            # –°–æ—Ö—Ä–∞–Ω—è–µ–º –æ–±–Ω–æ–≤–ª–µ–Ω–Ω—ã–µ –∫–Ω–æ–ø–∫–∏
            success = await update_button_content(
                button_label,
                db_content.get('content'),
                db_content.get('photo_file_id'),
                json.dumps(buttons),
                db_content.get('parse_mode', 'HTML'),
                db_content.get('parent_id')
            )

            if success:
                # –°–æ–∑–¥–∞–µ–º –ø—É—Å—Ç–æ–π –∫–æ–Ω—Ç–µ–Ω—Ç –¥–ª—è –ø–æ–¥–º–µ–Ω—é
                await update_button_content(
                    submenu_id,
                    f"–ö–æ–Ω—Ç–µ–Ω—Ç –¥–ª—è: {button_text}",
                    None,
                    None,
                    'HTML',
                    button_label  # parent_id
                )

                await message.answer(
                    f"‚úÖ –ö–Ω–æ–ø–∫–∞-–º–µ–Ω—é '{button_text}' –¥–æ–±–∞–≤–ª–µ–Ω–∞!\n\n"
                    f"–ß—Ç–æ–±—ã –æ—Ç—Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å –µ—ë –∫–æ–Ω—Ç–µ–Ω—Ç, –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ:\n"
                    f"<code>GOTO:db:{submenu_id}</code>",
                    parse_mode=ParseMode.HTML
                )
            else:
                await message.answer("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –¥–æ–±–∞–≤–ª–µ–Ω–∏–∏ –∫–Ω–æ–ø–∫–∏")
        else:
            await message.answer("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ –∫–æ–Ω—Ç–µ–Ω—Ç–∞ –≤ –ë–î")

        await state.clear()
        await admin_button(message, state)

@router.message(ContentEditorStates.waiting_button_url)
async def content_editor_button_url_received(message: types.Message, state: FSMContext):
    """–ü–æ–ª—É—á–µ–Ω URL –∫–Ω–æ–ø–∫–∏"""
    if message.text == "‚¨ÖÔ∏è –û—Ç–º–µ–Ω–∞":
        await state.set_state(ContentEditorStates.selecting_menu)
        return await content_editor_start(message, state)

    data = await state.get_data()
    menu_id = data.get('editing_menu_id')
    button_text = data.get('button_text')
    button_url = message.text

    # –î–æ–±–∞–≤–ª—è–µ–º https:// –µ—Å–ª–∏ –Ω–µ —É–∫–∞–∑–∞–Ω–æ
    if not button_url.startswith('http'):
        button_url = f'https://{button_url}'

    # –û–ø—Ä–µ–¥–µ–ª—è–µ–º button_label –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç —Ç–∏–ø–∞ –º–µ–Ω—é
    if menu_id.startswith('db:'):
        button_label = menu_id[3:]
    elif menu_id.startswith('static:'):
        button_label = menu_id[7:]
    else:
        await message.answer("‚ùå –ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π —Ç–∏–ø –º–µ–Ω—é")
        await state.clear()
        await admin_button(message, state)
        return

    # –ü–æ–ª—É—á–∞–µ–º –∏–ª–∏ —Å–æ–∑–¥–∞–µ–º –∫–æ–Ω—Ç–µ–Ω—Ç –≤ –ë–î
    db_content = await get_button_content(button_label)

    # –ï—Å–ª–∏ –∫–æ–Ω—Ç–µ–Ω—Ç–∞ –Ω–µ—Ç (–¥–ª—è —Å—Ç–∞—Ç–∏—á–µ—Å–∫–∏—Ö –º–µ–Ω—é), —Å–æ–∑–¥–∞–µ–º –∑–∞–ø–∏—Å—å
    if not db_content and menu_id.startswith('static:'):
        # –ü–æ–ª—É—á–∞–µ–º —Ç–µ–∫—Å—Ç –∏–∑ MENU_STRUCTURE
        parts = button_label.split(':')
        menu_key = parts[0]
        sub_key = parts[1] if len(parts) > 1 else None

        if sub_key and menu_key in MENU_STRUCTURE and sub_key in MENU_STRUCTURE[menu_key].get('submenu', {}):
            menu_data = MENU_STRUCTURE[menu_key]['submenu'][sub_key]
        elif menu_key in MENU_STRUCTURE:
            menu_data = MENU_STRUCTURE[menu_key]
        else:
            await message.answer("‚ùå –ú–µ–Ω—é –Ω–µ –Ω–∞–π–¥–µ–Ω–æ")
            await state.clear()
            await admin_button(message, state)
            return

        # –°–æ–∑–¥–∞–µ–º –∑–∞–ø–∏—Å—å –≤ –ë–î —Å —Ç–µ–∫—Å—Ç–æ–º –∏–∑ MENU_STRUCTURE
        await update_button_content(
            button_label,
            menu_data.get('text', ''),
            None,
            None,
            'HTML',
            None
        )
        # –ü–æ–ª—É—á–∞–µ–º —Å–æ–∑–¥–∞–Ω–Ω—ã–π –∫–æ–Ω—Ç–µ–Ω—Ç
        db_content = await get_button_content(button_label)

    if db_content:
        # –ü–æ–ª—É—á–∞–µ–º —Ç–µ–∫—É—â–∏–µ –∫–Ω–æ–ø–∫–∏
        try:
            buttons = json.loads(db_content['buttons_json']) if db_content.get('buttons_json') else []
        except:
            buttons = []

        # –î–æ–±–∞–≤–ª—è–µ–º –Ω–æ–≤—É—é –∫–Ω–æ–ø–∫—É
        buttons.append({
            'text': button_text,
            'url': button_url
        })

        # –°–æ—Ö—Ä–∞–Ω—è–µ–º
        success = await update_button_content(
            button_label,
            db_content.get('content'),
            db_content.get('photo_file_id'),
            json.dumps(buttons),
            db_content.get('parse_mode', 'HTML'),
            db_content.get('parent_id')
        )

        if success:
            await message.answer(f"‚úÖ –ö–Ω–æ–ø–∫–∞-—Å—Å—ã–ª–∫–∞ '{button_text}' –¥–æ–±–∞–≤–ª–µ–Ω–∞!")
        else:
            await message.answer("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –¥–æ–±–∞–≤–ª–µ–Ω–∏–∏")
    else:
        await message.answer("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ –∫–æ–Ω—Ç–µ–Ω—Ç–∞ –≤ –ë–î")

    await state.clear()
    await admin_button(message, state)

@router.message(ContentEditorStates.selecting_menu, F.text == "üîò –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –∏–Ω–ª–∞–π–Ω-–∫–Ω–æ–ø–∫–∞–º–∏")
async def content_editor_manage_inline_buttons(message: types.Message, state: FSMContext):
    """–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –∏–Ω–ª–∞–π–Ω-–∫–Ω–æ–ø–∫–∞–º–∏ - –ø–æ–∫–∞–∑ —Å–ø–∏—Å–∫–∞ —Å –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å—é —É–¥–∞–ª–µ–Ω–∏—è –∏ —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è"""
    data = await state.get_data()
    all_buttons = data.get('all_inline_buttons', [])

    if not all_buttons:
        await message.answer("üìã –ò–Ω–ª–∞–π–Ω-–∫–Ω–æ–ø–æ–∫ –Ω–µ—Ç")
        return

    # –§–æ—Ä–º–∏—Ä—É–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ —Å–æ —Å–ø–∏—Å–∫–æ–º –∫–Ω–æ–ø–æ–∫
    msg = "<b>üîò –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –∏–Ω–ª–∞–π–Ω-–∫–Ω–æ–ø–∫–∞–º–∏</b>\n\n"
    msg += "–°–ø–∏—Å–æ–∫ –∫–Ω–æ–ø–æ–∫:\n\n"

    for btn in all_buttons:
        source_label = " (—Å—Ç–∞—Ç–∏–∫–∞)" if btn['source'] == 'static' else " (–ë–î)"
        msg += f"{btn['index']}. {btn['text']} ‚Üí {btn['type']}{source_label}\n"

    msg += "\nüí° –î–ª—è —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –æ—Ç–ø—Ä–∞–≤—å—Ç–µ:\n"
    msg += "‚Ä¢ <code>DEL:‚Ññ</code> - —É–¥–∞–ª–∏—Ç—å –∫–Ω–æ–ø–∫—É\n"
    msg += "‚Ä¢ <code>RENAME:‚Ññ:–ù–æ–≤–æ–µ –Ω–∞–∑–≤–∞–Ω–∏–µ</code> - –ø–µ—Ä–µ–∏–º–µ–Ω–æ–≤–∞—Ç—å\n"
    msg += "–ü—Ä–∏–º–µ—Ä: <code>DEL:2</code> –∏–ª–∏ <code>RENAME:1:–ù–æ–≤–æ–µ –∏–º—è</code>"

    await state.set_state(ContentEditorStates.managing_inline_buttons)
    await message.answer(
        msg,
        reply_markup=ReplyKeyboardMarkup(
            keyboard=[[KeyboardButton(text="‚¨ÖÔ∏è –ù–∞–∑–∞–¥")]],
            resize_keyboard=True
        ),
        parse_mode=ParseMode.HTML
    )

@router.message(ContentEditorStates.managing_inline_buttons)
async def content_editor_process_button_command(message: types.Message, state: FSMContext):
    """–û–±—Ä–∞–±–æ—Ç–∫–∞ –∫–æ–º–∞–Ω–¥ —É–¥–∞–ª–µ–Ω–∏—è –∏ –ø–µ—Ä–µ–∏–º–µ–Ω–æ–≤–∞–Ω–∏—è –∫–Ω–æ–ø–æ–∫"""
    if message.text == "‚¨ÖÔ∏è –ù–∞–∑–∞–¥":
        await state.set_state(ContentEditorStates.selecting_menu)
        data = await state.get_data()
        menu_id = data.get('editing_menu_id')
        fake_msg = message.model_copy()
        fake_msg.text = f"EDIT:{menu_id}"
        return await content_editor_select(fake_msg, state)

    text = message.text.strip()
    data = await state.get_data()
    menu_id = data.get('editing_menu_id')
    all_buttons = data.get('all_inline_buttons', [])

    # –û–±—Ä–∞–±–æ—Ç–∫–∞ —É–¥–∞–ª–µ–Ω–∏—è: DEL:‚Ññ
    if text.upper().startswith('DEL:'):
        try:
            btn_num = int(text.split(':', 1)[1])
            btn_to_delete = next((b for b in all_buttons if b['index'] == btn_num), None)

            if not btn_to_delete:
                await message.answer("‚ùå –ö–Ω–æ–ø–∫–∞ —Å —Ç–∞–∫–∏–º –Ω–æ–º–µ—Ä–æ–º –Ω–µ –Ω–∞–π–¥–µ–Ω–∞")
                return

            # –£–¥–∞–ª—è–µ–º –∫–Ω–æ–ø–∫—É
            success = await delete_inline_button(menu_id, btn_to_delete)

            if success:
                await message.answer(f"‚úÖ –ö–Ω–æ–ø–∫–∞ '{btn_to_delete['text']}' —É–¥–∞–ª–µ–Ω–∞!")
                await state.set_state(ContentEditorStates.selecting_menu)
                fake_msg = message.model_copy()
                fake_msg.text = f"EDIT:{menu_id}"
                return await content_editor_select(fake_msg, state)
            else:
                await message.answer("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ —É–¥–∞–ª–µ–Ω–∏–∏ –∫–Ω–æ–ø–∫–∏")
        except (ValueError, IndexError):
            await message.answer("‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ: DEL:‚Ññ")
        return

    # –û–±—Ä–∞–±–æ—Ç–∫–∞ –ø–µ—Ä–µ–∏–º–µ–Ω–æ–≤–∞–Ω–∏—è: RENAME:‚Ññ:–ù–æ–≤–æ–µ –Ω–∞–∑–≤–∞–Ω–∏–µ
    if text.upper().startswith('RENAME:'):
        try:
            parts = text.split(':', 2)
            if len(parts) < 3:
                await message.answer("‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ: RENAME:‚Ññ:–ù–æ–≤–æ–µ –Ω–∞–∑–≤–∞–Ω–∏–µ")
                return

            btn_num = int(parts[1])
            new_name = parts[2].strip()

            if not new_name:
                await message.answer("‚ùå –ù–æ–≤–æ–µ –Ω–∞–∑–≤–∞–Ω–∏–µ –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º")
                return

            btn_to_rename = next((b for b in all_buttons if b['index'] == btn_num), None)

            if not btn_to_rename:
                await message.answer("‚ùå –ö–Ω–æ–ø–∫–∞ —Å —Ç–∞–∫–∏–º –Ω–æ–º–µ—Ä–æ–º –Ω–µ –Ω–∞–π–¥–µ–Ω–∞")
                return

            # –ü–µ—Ä–µ–∏–º–µ–Ω–æ–≤—ã–≤–∞–µ–º –∫–Ω–æ–ø–∫—É
            success = await rename_inline_button(menu_id, btn_to_rename, new_name)

            if success:
                await message.answer(f"‚úÖ –ö–Ω–æ–ø–∫–∞ –ø–µ—Ä–µ–∏–º–µ–Ω–æ–≤–∞–Ω–∞: '{btn_to_rename['text']}' ‚Üí '{new_name}'")
                await state.set_state(ContentEditorStates.selecting_menu)
                fake_msg = message.model_copy()
                fake_msg.text = f"EDIT:{menu_id}"
                return await content_editor_select(fake_msg, state)
            else:
                await message.answer("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–µ—Ä–µ–∏–º–µ–Ω–æ–≤–∞–Ω–∏–∏ –∫–Ω–æ–ø–∫–∏")
        except (ValueError, IndexError):
            await message.answer("‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ: RENAME:‚Ññ:–ù–æ–≤–æ–µ –Ω–∞–∑–≤–∞–Ω–∏–µ")
        return

    await message.answer("‚ùå –ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –∫–æ–º–∞–Ω–¥–∞. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ DEL:‚Ññ –∏–ª–∏ RENAME:‚Ññ:–ù–æ–≤–æ–µ –Ω–∞–∑–≤–∞–Ω–∏–µ")

@router.message(ContentEditorStates.editing_inline_buttons)
async def content_editor_save_inline_buttons(message: types.Message, state: FSMContext):
    """–°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –∏–Ω–ª–∞–π–Ω-–∫–Ω–æ–ø–æ–∫"""
    if message.text == "‚¨ÖÔ∏è –û—Ç–º–µ–Ω–∞":
        await state.set_state(ContentEditorStates.selecting_menu)
        return await content_editor_start(message, state)

    data = await state.get_data()
    menu_id = data.get('editing_menu_id')

    if not menu_id.startswith('db:'):
        await message.answer("‚ö†Ô∏è –ò–Ω–ª–∞–π–Ω-–∫–Ω–æ–ø–∫–∏ –º–æ–∂–Ω–æ —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å —Ç–æ–ª—å–∫–æ –¥–ª—è –∫–Ω–æ–ø–æ–∫ –∏–∑ –ë–î")
        await state.clear()
        return await admin_button(message, state)

    button_label = menu_id[3:]
    db_content = await get_button_content(button_label)

    if not db_content:
        await message.answer("‚ùå –ö–æ–Ω—Ç–µ–Ω—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω –≤ –ë–î")
        await state.clear()
        return await admin_button(message, state)

    # –û–±—Ä–∞–±–æ—Ç–∫–∞ —É–¥–∞–ª–µ–Ω–∏—è –≤—Å–µ—Ö –∫–Ω–æ–ø–æ–∫
    if message.text.lower() == "—É–¥–∞–ª–∏—Ç—å –≤—Å–µ":
        success = await update_button_content(
            button_label,
            db_content.get('content'),
            db_content.get('photo_file_id'),
            None,  # –£–¥–∞–ª—è–µ–º –≤—Å–µ –∫–Ω–æ–ø–∫–∏
            db_content.get('parse_mode', 'HTML'),
            db_content.get('parent_id')
        )
        if success:
            await message.answer("‚úÖ –í—Å–µ –∏–Ω–ª–∞–π–Ω-–∫–Ω–æ–ø–∫–∏ —É–¥–∞–ª–µ–Ω—ã!")
        else:
            await message.answer("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ —É–¥–∞–ª–µ–Ω–∏–∏")
        await state.clear()
        return await admin_button(message, state)

    # –ü–∞—Ä—Å–∏–Ω–≥ –Ω–æ–≤—ã—Ö –∫–Ω–æ–ø–æ–∫
    new_buttons = []
    lines = message.text.strip().split('\n')

    for line in lines:
        if '|' in line:
            parts = line.split('|', 1)
            text = parts[0].strip()
            url = parts[1].strip()

            if text and url:
                new_buttons.append({
                    'text': text,
                    'url': url if url.startswith('http') else f'https://{url}'
                })

    if not new_buttons:
        await message.answer("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å —Ä–∞—Å–ø–æ–∑–Ω–∞—Ç—å –∫–Ω–æ–ø–∫–∏. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ —Ñ–æ—Ä–º–∞—Ç: –¢–µ–∫—Å—Ç | URL")
        return

    # –°–æ—Ö—Ä–∞–Ω—è–µ–º
    success = await update_button_content(
        button_label,
        db_content.get('content'),
        db_content.get('photo_file_id'),
        json.dumps(new_buttons),
        db_content.get('parse_mode', 'HTML'),
        db_content.get('parent_id')
    )

    if success:
        await message.answer(f"‚úÖ –°–æ—Ö—Ä–∞–Ω–µ–Ω–æ {len(new_buttons)} –∏–Ω–ª–∞–π–Ω-–∫–Ω–æ–ø–æ–∫!")
    else:
        await message.answer("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–∏")

    await state.clear()
    await admin_button(message, state)

@router.message(ContentEditorStates.selecting_menu, F.text == "‚¨ÖÔ∏è –ù–∞–∑–∞–¥")
async def content_editor_back(message: types.Message, state: FSMContext):
    """–í–æ–∑–≤—Ä–∞—Ç –≤ –∞–¥–º–∏–Ω-–ø–∞–Ω–µ–ª—å"""
    await state.clear()
    await admin_button(message, state)

# ============ –ö–û–ù–ï–¶ –ù–û–í–û–ì–û –†–ï–î–ê–ö–¢–û–†–ê ============

@router.message(F.text == "üìä –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞")
async def show_statistics(message: types.Message):
    if message.from_user.id != ADMIN_ID:
        return

    stats = await get_stats()
    text = f"üìä <b>–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –±–æ—Ç–∞</b>\n\n"
    text += f"üë• –í—Å–µ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π: <code>{stats['user_count']}</code>\n\n"

    # Keyboard buttons stats
    text += f"‚å®Ô∏è <b>–¢–æ–ø –Ω–∞–∂–∞—Ç–∏–π –Ω–∞ –∫–Ω–æ–ø–∫–∏ –º–µ–Ω—é:</b>\n"
    # Filter keyboard buttons from clicks (they are usually simple labels from MENU_STRUCTURE)
    keyboard_labels = [m['label'] for m in MENU_STRUCTURE.values()]
    # Also add nested submenu labels
    for m in MENU_STRUCTURE.values():
        if 'submenu' in m:
            keyboard_labels.extend([sm['label'] for sm in m['submenu'].values()])

    kb_clicks = [c for c in stats['clicks'] if c['button_name'] in keyboard_labels]

    if kb_clicks:
        for i, row in enumerate(kb_clicks, 1):
            text += f"{i}. {row['button_name']}: <code>{row['click_count']}</code>\n"
    else:
        text += "–î–∞–Ω–Ω—ã—Ö –ø–æ–∫–∞ –Ω–µ—Ç.\n"

    await message.answer(text, parse_mode=ParseMode.HTML)


@router.message(F.text == "üì¢ –†–∞—Å—Å—ã–ª–∫–∞")
async def start_broadcast(message: types.Message, state: FSMContext):
    if message.from_user.id != ADMIN_ID:
        await message.answer("–£ –≤–∞—Å –Ω–µ—Ç –¥–æ—Å—Ç—É–ø–∞.")
        return

    await state.set_state(BroadcastStates.waiting_for_text)
    await message.answer(
        "–í–≤–µ–¥–∏—Ç–µ —Ç–µ–∫—Å—Ç —Ä–∞—Å—Å—ã–ª–∫–∏ (–ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è HTML —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ: <b>–∂–∏—Ä–Ω—ã–π</b>, <i>–Ω–∞–∫–ª–æ–Ω–Ω—ã–π</i>, <u>–ø–æ–¥—á–µ—Ä–∫–Ω—É—Ç—ã–π</u>):",
        reply_markup=ReplyKeyboardMarkup(
            keyboard=[[KeyboardButton(text="‚¨ÖÔ∏è –û—Ç–º–µ–Ω–∞")]],
            resize_keyboard=True))


@router.message(F.text == "‚¨ÖÔ∏è –û—Ç–º–µ–Ω–∞")
async def cancel_broadcast(message: types.Message, state: FSMContext):
    await state.clear()
    keyboard = ReplyKeyboardMarkup(
        keyboard=[[KeyboardButton(text="üì¢ –†–∞—Å—Å—ã–ª–∫–∞")],
                  [KeyboardButton(text="üìä –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞")],
                  [KeyboardButton(text="üìù –†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å –∫–Ω–æ–ø–∫–∏")],
                  [KeyboardButton(text="üîô –í—ã–π—Ç–∏")]],
        resize_keyboard=True)
    await message.answer("–†–∞—Å—Å—ã–ª–∫–∞ –æ—Ç–º–µ–Ω–µ–Ω–∞.", reply_markup=keyboard)


@router.message(BroadcastStates.waiting_for_text)
async def process_broadcast_text(message: types.Message, state: FSMContext):
    await state.update_data(text_content=message.text)
    await state.set_state(BroadcastStates.waiting_for_photo)
    await message.answer(
        "–û—Ç–ø—Ä–∞–≤—å—Ç–µ —Ñ–æ—Ç–æ –¥–ª—è —Ä–∞—Å—Å—ã–ª–∫–∏ –∏–ª–∏ –Ω–∞–ø–∏—à–∏—Ç–µ '–ø—Ä–æ–ø—É—Å—Ç–∏—Ç—å' —á—Ç–æ–±—ã –ø—Ä–æ–¥–æ–ª–∂–∏—Ç—å –±–µ–∑ —Ñ–æ—Ç–æ:",
        reply_markup=ReplyKeyboardMarkup(
            keyboard=[[KeyboardButton(text="–ø—Ä–æ–ø—É—Å—Ç–∏—Ç—å")],
                      [KeyboardButton(text="‚¨ÖÔ∏è –û—Ç–º–µ–Ω–∞")]],
            resize_keyboard=True))


@router.message(BroadcastStates.waiting_for_photo)
async def process_broadcast_photo(message: types.Message, state: FSMContext):
    if message.text == "–ø—Ä–æ–ø—É—Å—Ç–∏—Ç—å":
        await state.update_data(photo_file_id=None)
        await state.set_state(BroadcastStates.waiting_for_buttons_menu)
        await message.answer(
            "–•–æ—Ç–∏—Ç–µ –¥–æ–±–∞–≤–∏—Ç—å –∫–Ω–æ–ø–∫–∏?",
            reply_markup=ReplyKeyboardMarkup(
                keyboard=[[KeyboardButton(text="‚úÖ –î–æ–±–∞–≤–∏—Ç—å –∫–Ω–æ–ø–∫–∏")],
                          [KeyboardButton(text="‚ùå –ë–µ–∑ –∫–Ω–æ–ø–æ–∫")],
                          [KeyboardButton(text="‚¨ÖÔ∏è –û—Ç–º–µ–Ω–∞")]],
                resize_keyboard=True))
    elif message.photo:
        photo_file_id = message.photo[-1].file_id
        await state.update_data(photo_file_id=photo_file_id)
        await state.set_state(BroadcastStates.waiting_for_buttons_menu)
        await message.answer(
            "–•–æ—Ç–∏—Ç–µ –¥–æ–±–∞–≤–∏—Ç—å –∫–Ω–æ–ø–∫–∏?",
            reply_markup=ReplyKeyboardMarkup(
                keyboard=[[KeyboardButton(text="‚úÖ –î–æ–±–∞–≤–∏—Ç—å –∫–Ω–æ–ø–∫–∏")],
                          [KeyboardButton(text="‚ùå –ë–µ–∑ –∫–Ω–æ–ø–æ–∫")],
                          [KeyboardButton(text="‚¨ÖÔ∏è –û—Ç–º–µ–Ω–∞")]],
                resize_keyboard=True))
    else:
        await message.answer("–û—Ç–ø—Ä–∞–≤—å—Ç–µ —Ñ–æ—Ç–æ –∏–ª–∏ –Ω–∞–ø–∏—à–∏—Ç–µ '–ø—Ä–æ–ø—É—Å—Ç–∏—Ç—å'.")


@router.message(BroadcastStates.waiting_for_buttons_menu)
async def process_buttons_menu(message: types.Message, state: FSMContext):
    if message.text == "‚úÖ –î–æ–±–∞–≤–∏—Ç—å –∫–Ω–æ–ø–∫–∏":
        await state.set_state(BroadcastStates.waiting_for_button_name)
        await state.update_data(buttons=[])
        await message.answer("–í–≤–µ–¥–∏—Ç–µ –Ω–∞–∑–≤–∞–Ω–∏–µ –∫–Ω–æ–ø–∫–∏:",
                             reply_markup=ReplyKeyboardMarkup(
                                 keyboard=[[KeyboardButton(text="‚¨ÖÔ∏è –û—Ç–º–µ–Ω–∞")]],
                                 resize_keyboard=True))
    elif message.text == "‚ùå –ë–µ–∑ –∫–Ω–æ–ø–æ–∫":
        await proceed_to_confirm(message, state)
    else:
        await message.answer("–í—ã–±–µ—Ä–∏—Ç–µ –æ–¥–∏–Ω –∏–∑ –≤–∞—Ä–∏–∞–Ω—Ç–æ–≤.")


@router.message(BroadcastStates.waiting_for_button_name)
async def process_button_name(message: types.Message, state: FSMContext):
    await state.update_data(button_name=message.text)
    await state.set_state(BroadcastStates.waiting_for_button_url)
    await message.answer(
        "–í–≤–µ–¥–∏—Ç–µ —Å—Å—ã–ª–∫—É –¥–ª—è –∫–Ω–æ–ø–∫–∏ (–Ω–∞–ø—Ä–∏–º–µ—Ä: https://t.me/...):",
        reply_markup=ReplyKeyboardMarkup(
            keyboard=[[KeyboardButton(text="‚¨ÖÔ∏è –û—Ç–º–µ–Ω–∞")]],
            resize_keyboard=True))


@router.message(BroadcastStates.waiting_for_button_url)
async def process_button_url(message: types.Message, state: FSMContext):
    data = await state.get_data()
    button_name = data.get('button_name', '')
    buttons = data.get('buttons', [])

    buttons.append({'text': button_name, 'url': message.text})

    await state.update_data(buttons=buttons)
    await state.set_state(BroadcastStates.waiting_for_buttons_menu)

    buttons_list = "\n".join(
        [f"‚Ä¢ {btn['text']}: {btn['url']}" for btn in buttons])

    await message.answer(
        f"‚úÖ –ö–Ω–æ–ø–∫–∞ –¥–æ–±–∞–≤–ª–µ–Ω–∞!\n\n–î–æ–±–∞–≤–ª–µ–Ω–Ω—ã–µ –∫–Ω–æ–ø–∫–∏:\n{buttons_list}\n\n–•–æ—Ç–∏—Ç–µ –¥–æ–±–∞–≤–∏—Ç—å –µ—â—ë –æ–¥–Ω—É?",
        reply_markup=ReplyKeyboardMarkup(
            keyboard=[[KeyboardButton(text="‚ûï –î–æ–±–∞–≤–∏—Ç—å –µ—â—ë")],
                      [KeyboardButton(text="‚úÖ –ì–æ—Ç–æ–≤–æ")],
                      [KeyboardButton(text="‚¨ÖÔ∏è –û—Ç–º–µ–Ω–∞")]],
            resize_keyboard=True))


async def proceed_to_confirm(message: types.Message, state: FSMContext):
    data = await state.get_data()
    await state.set_state(BroadcastStates.confirm_broadcast)

    preview_text = data['text_content']
    if data.get('photo_file_id'):
        preview_text += "\n\nüì∏ (–§–æ—Ç–æ –±—É–¥–µ—Ç –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ)"

    buttons = data.get('buttons', [])
    if buttons:
        buttons_list = "\n".join(
            [f"üîò {btn['text']}: {btn['url']}" for btn in buttons])
        preview_text += f"\n\n<b>–ö–Ω–æ–ø–∫–∏:</b>\n{buttons_list}"

    confirm_keyboard = ReplyKeyboardMarkup(keyboard=[[
        KeyboardButton(text="‚úÖ –û—Ç–ø—Ä–∞–≤–∏—Ç—å"),
        KeyboardButton(text="‚ùå –û—Ç–º–µ–Ω–∞")
    ]],
                                           resize_keyboard=True)

    await message.answer(f"<b>–ü—Ä–µ–¥–ø—Ä–æ—Å–º–æ—Ç—Ä —Ä–∞—Å—Å—ã–ª–∫–∏:</b>\n\n{preview_text}",
                         reply_markup=confirm_keyboard,
                         parse_mode=ParseMode.HTML)


@router.message(F.text == "‚ûï –î–æ–±–∞–≤–∏—Ç—å –µ—â—ë")
async def add_another_button(message: types.Message, state: FSMContext):
    await state.set_state(BroadcastStates.waiting_for_button_name)
    await message.answer("–í–≤–µ–¥–∏—Ç–µ –Ω–∞–∑–≤–∞–Ω–∏–µ –∫–Ω–æ–ø–∫–∏:",
                         reply_markup=ReplyKeyboardMarkup(
                             keyboard=[[KeyboardButton(text="‚¨ÖÔ∏è –û—Ç–º–µ–Ω–∞")]],
                             resize_keyboard=True))


@router.message(F.text == "‚úÖ –ì–æ—Ç–æ–≤–æ")
async def buttons_done(message: types.Message, state: FSMContext):
    await proceed_to_confirm(message, state)


@router.message(BroadcastStates.confirm_broadcast)
async def confirm_and_send_broadcast(message: types.Message,
                                     state: FSMContext):
    if message.text == "‚úÖ –û—Ç–ø—Ä–∞–≤–∏—Ç—å":
        data = await state.get_data()
        users = await get_all_users()

        # Build inline keyboard from buttons
        buttons_keyboard = None
        buttons = data.get('buttons', [])
        if buttons:
            keyboard_buttons = []
            for btn in buttons:
                keyboard_buttons.append(
                    InlineKeyboardButton(text=btn['text'], url=btn['url']))
            buttons_keyboard = InlineKeyboardMarkup(
                inline_keyboard=[keyboard_buttons])

        sent_count = 0
        tasks = []
        for user_id in users:
            try:
                if data.get('photo_file_id'):
                    tasks.append(bot.send_photo(user_id,
                                         data['photo_file_id'],
                                         caption=data['text_content'],
                                         parse_mode=ParseMode.HTML,
                                         reply_markup=buttons_keyboard))
                else:
                    tasks.append(bot.send_message(user_id,
                                           data['text_content'],
                                           parse_mode=ParseMode.HTML,
                                           reply_markup=buttons_keyboard))

                if len(tasks) >= 30:
                    results = await asyncio.gather(*tasks, return_exceptions=True)
                    for res in results:
                        if not isinstance(res, Exception):
                            sent_count += 1
                        else:
                            logger.error(f"Broadcast error: {res}")
                    tasks = []
                    await asyncio.sleep(1) # Respect Telegram rate limits (30 msg/sec)
            except Exception as e:
                logger.error(f"Error preparing for {user_id}: {e}")

        if tasks:
            results = await asyncio.gather(*tasks, return_exceptions=True)
            for res in results:
                if not isinstance(res, Exception):
                    sent_count += 1
                else:
                    logger.error(f"Broadcast error: {res}")

        await state.clear()
        admin_keyboard = ReplyKeyboardMarkup(
            keyboard=[[KeyboardButton(text="üì¢ –†–∞—Å—Å—ã–ª–∫–∞")],
                      [KeyboardButton(text="üîô –í—ã–π—Ç–∏")]],
            resize_keyboard=True)
        await message.answer(
            f"‚úÖ –†–∞—Å—Å—ã–ª–∫–∞ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–∞ {sent_count} –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è–º!",
            reply_markup=admin_keyboard)
    else:
        await state.clear()
        admin_keyboard = ReplyKeyboardMarkup(
            keyboard=[[KeyboardButton(text="üì¢ –†–∞—Å—Å—ã–ª–∫–∞")],
                      [KeyboardButton(text="üîô –í—ã–π—Ç–∏")]],
            resize_keyboard=True)
        await message.answer("–†–∞—Å—Å—ã–ª–∫–∞ –æ—Ç–º–µ–Ω–µ–Ω–∞.", reply_markup=admin_keyboard)



    await state.set_state(ChatsContinuationStates.selecting_chat_section)
    keyboard = ReplyKeyboardMarkup(keyboard=[[
        KeyboardButton(text="–ò–Ω—Ñ–æ–±–∏–∑–Ω–µ—Å"),
        KeyboardButton(text="–û–±—â–∏–µ [–∞–¥–º–∏–Ω]")
    ], [KeyboardButton(text="–¢–µ–º–∞—Ç–∏—á–µ—Å–∫–∏–µ [–∞–¥–º–∏–Ω]")
        ], [KeyboardButton(text="‚¨ÖÔ∏è –û—Ç–º–µ–Ω–∞")]],
                                   resize_keyboard=True)
    await message.answer("–í—ã–±–µ—Ä–∏—Ç–µ —Ä–∞–∑–¥–µ–ª —á–∞—Ç–æ–≤ –¥–ª—è —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è:",
                         reply_markup=keyboard)


@router.message(ChatsContinuationStates.selecting_chat_section)
async def select_chat_section(message: types.Message, state: FSMContext):
    section_map = {
        "–ò–Ω—Ñ–æ–±–∏–∑–Ω–µ—Å": "infobusiness",
        "–û–±—â–∏–µ [–∞–¥–º–∏–Ω]": "general_admin",
        "–¢–µ–º–∞—Ç–∏—á–µ—Å–∫–∏–µ [–∞–¥–º–∏–Ω]": "thematic_admin"
    }

    if message.text == "‚¨ÖÔ∏è –û—Ç–º–µ–Ω–∞":
        await state.clear()
        admin_keyboard = ReplyKeyboardMarkup(
            keyboard=[[KeyboardButton(text="üì¢ –†–∞—Å—Å—ã–ª–∫–∞")],
                      [KeyboardButton(text="üìä –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞")],
                      [KeyboardButton(text="üèó –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –º–µ–Ω—é")],
                      [KeyboardButton(text="üìù –†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å –∫–Ω–æ–ø–∫–∏")],
                      [KeyboardButton(text="üîô –í—ã–π—Ç–∏")]],
            resize_keyboard=True)
        await message.answer("–û—Ç–º–µ–Ω–µ–Ω–æ.", reply_markup=admin_keyboard)
        return

    section_key = section_map.get(message.text)
    if not section_key:
        await message.answer("–í—ã–±–µ—Ä–∏—Ç–µ —Ä–∞–∑–¥–µ–ª –∏–∑ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–Ω—ã—Ö.")
        return

    lines = CHATS_CONTINUATION.get(section_key, [])
    lines_text = "\n".join([f"{i+1}. {line}" for i, line in enumerate(lines)])

    await state.update_data(section_key=section_key)
    await state.set_state(ChatsContinuationStates.managing_lines)

    keyboard = ReplyKeyboardMarkup(
        keyboard=[[KeyboardButton(text="‚ûï –î–æ–±–∞–≤–∏—Ç—å —Å—Ç—Ä–æ–∫—É")],
                  [KeyboardButton(text="‚úèÔ∏è –†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å")],
                  [KeyboardButton(text="‚¨ÖÔ∏è –ù–∞–∑–∞–¥")]],
        resize_keyboard=True)

    await message.answer(
        f"<b>–†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ: {message.text}</b>\n\n<b>–¢–µ–∫—É—â–∏–µ —Å—Ç—Ä–æ–∫–∏:</b>\n{lines_text}\n\n–í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ:",
        reply_markup=keyboard,
        parse_mode=ParseMode.HTML)


@router.message(ChatsContinuationStates.managing_lines)
async def manage_chat_lines(message: types.Message, state: FSMContext):
    data = await state.get_data()
    section_key = data.get('section_key')

    if message.text == "‚¨ÖÔ∏è –ù–∞–∑–∞–¥":
        await state.clear()
        admin_keyboard = ReplyKeyboardMarkup(
            keyboard=[[KeyboardButton(text="üì¢ –†–∞—Å—Å—ã–ª–∫–∞")],
                      [KeyboardButton(text="üìä –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞")],
                      [KeyboardButton(text="üèó –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –º–µ–Ω—é")],
                      [KeyboardButton(text="üìù –†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å –∫–Ω–æ–ø–∫–∏")],
                      [KeyboardButton(text="üîô –í—ã–π—Ç–∏")]],
            resize_keyboard=True)
        await message.answer("–í–µ—Ä–Ω—É–ª–∏—Å—å –≤ –∞–¥–º–∏–Ω-–ø–∞–Ω–µ–ª—å.",
                             reply_markup=admin_keyboard)
        return

    if message.text == "‚ûï –î–æ–±–∞–≤–∏—Ç—å —Å—Ç—Ä–æ–∫—É":
        await state.set_state(ChatsContinuationStates.editing_line)
        await state.update_data(editing_action="add", accumulated_text="")
        await message.answer(
            "üìù –í–≤–µ–¥–∏—Ç–µ —Ç–µ–∫—Å—Ç (–º–æ–∂–Ω–æ –º–Ω–æ–≥–æ—Å—Ç—Ä–æ—á–Ω—ã–π):\n\n–í Telegram –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ Shift+Enter –¥–ª—è –ø–µ—Ä–µ–Ω–æ—Å–∞ —Å—Ç—Ä–æ–∫.",
            reply_markup=ReplyKeyboardMarkup(
                keyboard=[[KeyboardButton(text="‚úÖ –ì–æ—Ç–æ–≤–æ")],
                          [KeyboardButton(text="‚¨ÖÔ∏è –û—Ç–º–µ–Ω–∞")]],
                resize_keyboard=True))

    elif message.text == "‚úèÔ∏è –†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å":
        lines = CHATS_CONTINUATION.get(section_key, [])
        if not lines:
            await message.answer("–ù–µ—Ç —Å—Ç—Ä–æ–∫ –¥–ª—è —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è.")
            return

        lines_text = "\n".join(
            [f"{i+1}. {line}" for i, line in enumerate(lines)])
        await state.set_state(ChatsContinuationStates.editing_line)
        await state.update_data(editing_action="edit")

        await message.answer(
            f"–ö–∞–∫—É—é —Å—Ç—Ä–æ–∫—É —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å?\n\n{lines_text}\n\n–í–≤–µ–¥–∏—Ç–µ –Ω–æ–º–µ—Ä (1, 2, 3...):",
            reply_markup=ReplyKeyboardMarkup(
                keyboard=[[KeyboardButton(text="‚¨ÖÔ∏è –û—Ç–º–µ–Ω–∞")]],
                resize_keyboard=True))


@router.message(ChatsContinuationStates.editing_line)
async def save_chat_line(message: types.Message, state: FSMContext):
    if message.text == "‚¨ÖÔ∏è –û—Ç–º–µ–Ω–∞":
        data = await state.get_data()
        section_key = data.get('section_key')
        lines = CHATS_CONTINUATION.get(section_key, [])
        lines_text = "\n".join(
            [f"{i+1}. {line}" for i, line in enumerate(lines)])

        await state.set_state(ChatsContinuationStates.managing_lines)
        keyboard = ReplyKeyboardMarkup(
            keyboard=[[KeyboardButton(text="‚ûï –î–æ–±–∞–≤–∏—Ç—å —Å—Ç—Ä–æ–∫—É")],
                      [KeyboardButton(text="‚úèÔ∏è –†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å")],
                      [KeyboardButton(text="‚¨ÖÔ∏è –ù–∞–∑–∞–¥")]],
            resize_keyboard=True)

        await message.answer(f"<b>–¢–µ–∫—É—â–∏–µ —Å—Ç—Ä–æ–∫–∏:</b>\n{lines_text}",
                             reply_markup=keyboard,
                             parse_mode=ParseMode.HTML)
        return

    data = await state.get_data()
    section_key = data.get('section_key')
    editing_action = data.get('editing_action')
    lines = CHATS_CONTINUATION.get(section_key, [])
    accumulated_text = data.get('accumulated_text', '')

    if editing_action == "add":
        if message.text == "‚úÖ –ì–æ—Ç–æ–≤–æ":
            if accumulated_text:
                lines.append(accumulated_text)
                CHATS_CONTINUATION[section_key] = lines
                save_chats_continuation()

                lines_text = "\n".join(
                    [f"{i+1}. {line}" for i, line in enumerate(lines)])
                await state.set_state(ChatsContinuationStates.managing_lines)
                keyboard = ReplyKeyboardMarkup(
                    keyboard=[[KeyboardButton(text="‚ûï –î–æ–±–∞–≤–∏—Ç—å —Å—Ç—Ä–æ–∫—É")],
                              [KeyboardButton(text="‚úèÔ∏è –†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å")],
                              [KeyboardButton(text="‚¨ÖÔ∏è –ù–∞–∑–∞–¥")]],
                    resize_keyboard=True)

                await message.answer(
                    f"‚úÖ –¢–µ–∫—Å—Ç –¥–æ–±–∞–≤–ª–µ–Ω!\n\n<b>–¢–µ–∫—É—â–∏–µ —Å—Ç—Ä–æ–∫–∏:</b>\n{lines_text}",
                    reply_markup=keyboard,
                    parse_mode=ParseMode.HTML)
            else:
                await message.answer(
                    "–¢–µ–∫—Å—Ç –ø—É—Å—Ç. –í–≤–µ–¥–∏—Ç–µ —Ç–µ–∫—Å—Ç –ø–µ—Ä–µ–¥ –Ω–∞–∂–∞—Ç–∏–µ–º '–ì–æ—Ç–æ–≤–æ'.")
        else:
            # –ù–∞–∫–∞–ø–ª–∏–≤–∞–µ–º —Ç–µ–∫—Å—Ç
            new_accumulated = accumulated_text + message.text if accumulated_text else message.text
            await state.update_data(accumulated_text=new_accumulated)

            await message.answer(
                f"üìù –¢–µ–∫—Å—Ç —Å–æ—Ö—Ä–∞–Ω—ë–Ω (–≤—Å–µ–≥–æ —Å–∏–º–≤–æ–ª–æ–≤: {len(new_accumulated)})\n\n–ü—Ä–æ–¥–æ–ª–∂–∞–π—Ç–µ –≤–≤–æ–¥–∏—Ç—å —Ç–µ–∫—Å—Ç –∏–ª–∏ –Ω–∞–∂–º–∏—Ç–µ ‚úÖ –ì–æ—Ç–æ–≤–æ:",
                reply_markup=ReplyKeyboardMarkup(
                    keyboard=[[KeyboardButton(text="‚úÖ –ì–æ—Ç–æ–≤–æ")],
                              [KeyboardButton(text="‚¨ÖÔ∏è –û—Ç–º–µ–Ω–∞")]],
                    resize_keyboard=True))

    elif editing_action == "edit":
        try:
            line_num = int(message.text) - 1
            if 0 <= line_num < len(lines):
                await state.update_data(line_num=line_num,
                                        accumulated_text=lines[line_num])
                await state.set_state(ChatsContinuationStates.editing_line)
                await state.update_data(editing_action="update")

                await message.answer(
                    f"–¢–µ–∫—É—â–∏–π —Ç–µ–∫—Å—Ç —Å—Ç—Ä–æ–∫–∏ {line_num + 1}:\n<code>{lines[line_num]}</code>\n\n–í–≤–µ–¥–∏—Ç–µ –Ω–æ–≤—ã–π —Ç–µ–∫—Å—Ç –∏–ª–∏ –Ω–∞–∂–º–∏—Ç–µ ‚úÖ –ì–æ—Ç–æ–≤–æ:",
                    reply_markup=ReplyKeyboardMarkup(
                        keyboard=[[KeyboardButton(text="‚úÖ –ì–æ—Ç–æ–≤–æ")],
                                  [KeyboardButton(text="‚¨ÖÔ∏è –û—Ç–º–µ–Ω–∞")]],
                        resize_keyboard=True),
                    parse_mode=ParseMode.HTML)
            else:
                await message.answer("–ù–µ–≤–µ—Ä–Ω—ã–π –Ω–æ–º–µ—Ä —Å—Ç—Ä–æ–∫–∏.")
        except ValueError:
            await message.answer("–í–≤–µ–¥–∏—Ç–µ —á–∏—Å–ª–æ (1, 2, 3...).")

    elif editing_action == "update":
        line_num = data.get('line_num')

        if message.text == "‚úÖ –ì–æ—Ç–æ–≤–æ":
            if accumulated_text:
                lines[line_num] = accumulated_text
                CHATS_CONTINUATION[section_key] = lines
                save_chats_continuation()

                lines_text = "\n".join(
                    [f"{i+1}. {line}" for i, line in enumerate(lines)])
                await state.set_state(ChatsContinuationStates.managing_lines)
                keyboard = ReplyKeyboardMarkup(
                    keyboard=[[KeyboardButton(text="‚ûï –î–æ–±–∞–≤–∏—Ç—å —Å—Ç—Ä–æ–∫—É")],
                              [KeyboardButton(text="‚úèÔ∏è –†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å")],
                              [KeyboardButton(text="‚¨ÖÔ∏è –ù–∞–∑–∞–¥")]],
                    resize_keyboard=True)

                await message.answer(
                    f"‚úÖ –¢–µ–∫—Å—Ç –æ–±–Ω–æ–≤–ª–µ–Ω!\n\n<b>–¢–µ–∫—É—â–∏–µ —Å—Ç—Ä–æ–∫–∏:</b>\n{lines_text}",
                    reply_markup=keyboard,
                    parse_mode=ParseMode.HTML)
        else:
            # –ù–∞–∫–∞–ø–ª–∏–≤–∞–µ–º —Ç–µ–∫—Å—Ç –ø—Ä–∏ —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏–∏
            new_accumulated = accumulated_text + message.text if accumulated_text else message.text
            await state.update_data(accumulated_text=new_accumulated)

            await message.answer(
                f"üìù –¢–µ–∫—Å—Ç –æ–±–Ω–æ–≤–ª—ë–Ω (–≤—Å–µ–≥–æ —Å–∏–º–≤–æ–ª–æ–≤: {len(new_accumulated)})\n\n–ü—Ä–æ–¥–æ–ª–∂–∞–π—Ç–µ –≤–≤–æ–¥–∏—Ç—å —Ç–µ–∫—Å—Ç –∏–ª–∏ –Ω–∞–∂–º–∏—Ç–µ ‚úÖ –ì–æ—Ç–æ–≤–æ:",
                reply_markup=ReplyKeyboardMarkup(
                    keyboard=[[KeyboardButton(text="‚úÖ –ì–æ—Ç–æ–≤–æ")],
                              [KeyboardButton(text="‚¨ÖÔ∏è –û—Ç–º–µ–Ω–∞")]],
                    resize_keyboard=True))


async def manage_menu(message: types.Message, state: FSMContext):
    buttons = await get_all_keyboard_buttons()
    # buttons - —ç—Ç–æ —Å–ø–∏—Å–æ–∫ –∑–∞–ø–∏—Å–µ–π, –≥–¥–µ b['label'] - —Ç–µ–∫—Å—Ç –∫–Ω–æ–ø–∫–∏
    keyboard_buttons = []
    for b in buttons:
        keyboard_buttons.append([KeyboardButton(text=b['label'])])

    keyboard_buttons.append([KeyboardButton(text="‚ûï –°–æ–∑–¥–∞—Ç—å –∫–Ω–æ–ø–∫—É")])
    keyboard_buttons.append([KeyboardButton(text="‚¨ÖÔ∏è –ù–∞–∑–∞–¥")])

    kb = ReplyKeyboardMarkup(keyboard=keyboard_buttons, resize_keyboard=True)
    await state.set_state(AdminMenuStates.managing_menu)
    await message.answer("üõ† <b>–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –º–µ–Ω—é</b>\n\n–ù–∞–∂–º–∏—Ç–µ –Ω–∞ –∫–Ω–æ–ø–∫—É, —á—Ç–æ–±—ã <b>—É–¥–∞–ª–∏—Ç—å</b> –µ—ë, –∏–ª–∏ –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ '‚ûï –°–æ–∑–¥–∞—Ç—å –∫–Ω–æ–ø–∫—É'.", reply_markup=kb, parse_mode=ParseMode.HTML)

@router.message(AdminMenuStates.managing_menu)
async def process_menu_management(message: types.Message, state: FSMContext):
    if message.text == "‚ûï –°–æ–∑–¥–∞—Ç—å –∫–Ω–æ–ø–∫—É":
        await state.set_state(AdminMenuStates.adding_button_label)
        await message.answer("–í–≤–µ–¥–∏—Ç–µ –Ω–∞–∑–≤–∞–Ω–∏–µ –¥–ª—è –Ω–æ–≤–æ–π –∫–Ω–æ–ø–∫–∏:", 
                             reply_markup=ReplyKeyboardMarkup(keyboard=[[KeyboardButton(text="‚¨ÖÔ∏è –û—Ç–º–µ–Ω–∞")]], resize_keyboard=True))
    elif message.text == "‚¨ÖÔ∏è –ù–∞–∑–∞–¥":
        await state.clear()
        await admin_button(message, state)
    else:
        buttons = await get_all_keyboard_buttons()
        labels = [b['label'] for b in buttons]
        if message.text in labels:
            if await delete_keyboard_button(message.text):
                await message.answer(f"‚úÖ –ö–Ω–æ–ø–∫–∞ '{message.text}' —É–¥–∞–ª–µ–Ω–∞.")
            else:
                await message.answer(f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ —É–¥–∞–ª–µ–Ω–∏–∏ –∫–Ω–æ–ø–∫–∏.")
            await manage_menu(message, state)

async def add_button_label(message: types.Message, state: FSMContext):
    if message.text == "‚¨ÖÔ∏è –û—Ç–º–µ–Ω–∞":
        return await manage_menu(message, state)

    clean_label = message.text.strip()
    print(f"[BOT_DEBUG] User provided button label: '{clean_label}'")
    await state.update_data(label=clean_label)
    await state.set_state(AdminMenuStates.adding_button_content)
    await message.answer(f"–û—Ç–ª–∏—á–Ω–æ! –¢–µ–ø–µ—Ä—å –≤–≤–µ–¥–∏—Ç–µ —Ç–µ–∫—Å—Ç –¥–ª—è –∫–Ω–æ–ø–∫–∏ '{clean_label}':")

@router.message(AdminMenuStates.adding_button_content)
async def add_button_content(message: types.Message, state: FSMContext):
    if message.text == "‚¨ÖÔ∏è –û—Ç–º–µ–Ω–∞":
        return await manage_menu(message, state)

    content = message.text
    print(f"[BOT_DEBUG] User provided button content (length: {len(content)})")
    await state.update_data(content=content)
    await state.set_state(AdminMenuStates.adding_button_photo)
    await message.answer("–ü—Ä–∏—à–ª–∏—Ç–µ —Ñ–æ—Ç–æ –∏–ª–∏ –Ω–∞–∂–º–∏—Ç–µ '–ü—Ä–æ–ø—É—Å—Ç–∏—Ç—å':", 
                         reply_markup=ReplyKeyboardMarkup(keyboard=[[KeyboardButton(text="–ü—Ä–æ–ø—É—Å—Ç–∏—Ç—å")], [KeyboardButton(text="‚¨ÖÔ∏è –û—Ç–º–µ–Ω–∞")]], resize_keyboard=True))

@router.message(AdminMenuStates.adding_button_photo)
async def add_button_photo(message: types.Message, state: FSMContext):
    if message.text == "‚¨ÖÔ∏è –û—Ç–º–µ–Ω–∞":
        return await manage_menu(message, state)

    if message.photo:
        await state.update_data(photo=message.photo[-1].file_id)

    await state.set_state(AdminMenuStates.adding_inline_button_text)
    await message.answer("–í–≤–µ–¥–∏—Ç–µ —Ç–µ–∫—Å—Ç –¥–ª—è –∏–Ω–ª–∞–π–Ω-–∫–Ω–æ–ø–∫–∏ (–∏–ª–∏ '–ü—Ä–æ–ø—É—Å—Ç–∏—Ç—å'):",
                         reply_markup=ReplyKeyboardMarkup(keyboard=[[KeyboardButton(text="–ü—Ä–æ–ø—É—Å—Ç–∏—Ç—å")], [KeyboardButton(text="‚¨ÖÔ∏è –û—Ç–º–µ–Ω–∞")]], resize_keyboard=True))

@router.message(AdminMenuStates.adding_inline_button_text)
async def add_inline_text(message: types.Message, state: FSMContext):
    if message.text == "‚¨ÖÔ∏è –û—Ç–º–µ–Ω–∞":
        return await manage_menu(message, state)

    if message.text == "–ü—Ä–æ–ø—É—Å—Ç–∏—Ç—å":
        data = await state.get_data()
        await finalize_button_creation(message, state, data)
        return

    await state.update_data(inline_text=message.text)
    await state.set_state(AdminMenuStates.adding_inline_button_url)
    await message.answer("–í–≤–µ–¥–∏—Ç–µ —Å—Å—ã–ª–∫—É –¥–ª—è –∏–Ω–ª–∞–π–Ω-–∫–Ω–æ–ø–∫–∏:")

@router.callback_query(F.data.startswith("dyn:"))
async def process_dynamic_inline(query: types.CallbackQuery, state: FSMContext):
    button_id = query.data[4:]
    print(f"\n[BOT_DEBUG_VERBOSE] === process_dynamic_inline Start ===")
    print(f"[BOT_DEBUG_VERBOSE] Callback Data: '{query.data}'")
    print(f"[BOT_DEBUG_VERBOSE] Raw Target ID from data: '{button_id}'")

    db_content = await get_button_content(button_id)
    if not db_content:
        # –ü–æ–ø—Ä–æ–±—É–µ–º –Ω–∞–π—Ç–∏ –ø–æ —Ç–µ–∫—Å—Ç—É –∫–Ω–æ–ø–∫–∏, –µ—Å–ª–∏ ID –Ω–µ —Å–æ–≤–ø–∞–ª –Ω–∞–ø—Ä—è–º—É—é
        print(f"[BOT_DEBUG_VERBOSE] DB Content NOT found for ID '{button_id}', attempting fallback fuzzy search...")
        all_btns = await get_all_keyboard_buttons()
        print(f"[BOT_DEBUG_VERBOSE] Searching through {len(all_btns)} labels...")
        for b in all_btns:
            b_lbl = b.get('label') if isinstance(b, dict) else (getattr(b, 'label', None) or b['label'] if hasattr(b, '__getitem__') else None)
            if b_lbl and b_lbl.strip().lower() == button_id.strip().lower():
                print(f"[BOT_DEBUG_VERBOSE] ‚úÖ Fallback Match Found: '{b_lbl}'")
                db_content = await get_button_content(b_lbl)
                if db_content:
                    print(f"[BOT_DEBUG_VERBOSE] Successfully loaded content for fuzzy match '{b_lbl}'")
                    break

    if db_content:
        print(f"[BOT_DEBUG_VERBOSE] ‚úÖ SUCCESS: Content found for '{button_id}'")
        print(f"[BOT_DEBUG_VERBOSE] DB Parent ID: '{db_content.get('parent_id')}'")
        msg_text = db_content.get('content', '–ù–µ—Ç —Å–æ–¥–µ—Ä–∂–∏–º–æ–≥–æ')
        photo = db_content.get('photo_file_id')
        kb = None

        if db_content.get('buttons_json'):
            print(f"[BOT_DEBUG_VERBOSE] Found inline buttons JSON: {db_content['buttons_json']}")
            try:
                btns = json.loads(db_content['buttons_json'])
                print(f"[BOT_DEBUG_VERBOSE] Parsed {len(btns)} buttons from JSON")
                inline_keyboard_list = []
                for i, b in enumerate(btns):
                    btn_text = b.get('text', '???')
                    if b.get('url') and b.get('url') != '–º–µ–Ω—é':
                        print(f"[BOT_DEBUG_VERBOSE] Inline Button {i+1}: '{btn_text}' -> URL: {b['url']}")
                        inline_keyboard_list.append([InlineKeyboardButton(text=btn_text, url=b['url'])])
                    else:
                        # –ï—Å–ª–∏ ID –Ω–µ –∑–∞–¥–∞–Ω –≤ JSON, —Ñ–æ—Ä–º–∏—Ä—É–µ–º –µ–≥–æ
                        target_id = b.get('id') or f"{button_id}:{btn_text}"
                        print(f"[BOT_DEBUG_VERBOSE] Inline Button {i+1}: '{btn_text}' -> Submenu ID: {target_id}")
                        inline_keyboard_list.append([InlineKeyboardButton(text=btn_text, callback_data=f"dyn:{target_id}")])

                # –ö–Ω–æ–ø–∫–∞ –Ω–∞–∑–∞–¥
                if db_content.get('parent_id'):
                    parent_id = db_content['parent_id']
                    print(f"[BOT_DEBUG_VERBOSE] Adding 'Back' button -> dyn:{parent_id}")
                    inline_keyboard_list.append([InlineKeyboardButton(text="üîô –ù–∞–∑–∞–¥", callback_data=f"dyn:{parent_id}")])
                else:
                    print(f"[BOT_DEBUG_VERBOSE] No parent_id, adding 'Back to Start' button")
                    inline_keyboard_list.append([InlineKeyboardButton(text="üîô –í –Ω–∞—á–∞–ª–æ", callback_data="main_menu")])

                kb = InlineKeyboardMarkup(inline_keyboard=inline_keyboard_list)
            except Exception as e:
                print(f"[BOT_DEBUG_VERBOSE] ‚ùå ERROR parsing inline buttons JSON: {e}")

        try:
            if photo:
                print(f"[BOT_DEBUG_VERBOSE] Updating message as Media (Photo: {photo[:15]}...)")
                await query.message.edit_media(
                    media=types.InputMediaPhoto(media=photo, caption=msg_text, parse_mode=ParseMode.HTML),
                    reply_markup=kb
                )
            else:
                print(f"[BOT_DEBUG_VERBOSE] Updating message as Text")
                await query.message.edit_text(msg_text, reply_markup=kb, parse_mode=ParseMode.HTML)
            print(f"[BOT_DEBUG_VERBOSE] ‚úÖ Message updated successfully")
        except Exception as e:
            if "message is not modified" in str(e):
                print("[BOT_DEBUG_VERBOSE] Message content is identical, nothing to update.")
            else:
                print(f"[BOT_DEBUG_VERBOSE] ‚ùå ERROR updating message: {e}")
                # Fallback to answer if edit fails
                if photo:
                    await query.message.answer_photo(photo, caption=msg_text, reply_markup=kb, parse_mode=ParseMode.HTML)
                else:
                    await query.message.answer(msg_text, reply_markup=kb, parse_mode=ParseMode.HTML)
    else:
        print(f"[BOT_DEBUG_VERBOSE] ‚ùå FAIL: Content NOT found in DB for ID: '{button_id}'")
        await query.answer("‚ùå –†–∞–∑–¥–µ–ª –Ω–µ –Ω–∞–π–¥–µ–Ω –≤ –±–∞–∑–µ –¥–∞–Ω–Ω—ã—Ö", show_alert=True)

    await query.answer()

@router.message(AdminMenuStates.adding_inline_button_url)
async def add_inline_url(message: types.Message, state: FSMContext):
    if message.text == "‚¨ÖÔ∏è –û—Ç–º–µ–Ω–∞":
        return await manage_menu(message, state)

    data = await state.get_data()
    inline_text = data.get('inline_text')

    if message.text == "–ö–Ω–æ–ø–∫–∞ —Å –º–µ–Ω—é":
        # –ü–µ—Ä–µ—Ö–æ–¥ –∫ —Å–æ–∑–¥–∞–Ω–∏—é –≤–ª–æ–∂–µ–Ω–Ω–æ–≥–æ –º–µ–Ω—é
        await state.update_data(is_nested=True)
        await state.set_state(AdminMenuStates.adding_button_label)
        await message.answer(f"–°–æ–∑–¥–∞–µ–º –≤–ª–æ–∂–µ–Ω–Ω–æ–µ –º–µ–Ω—é –¥–ª—è –∫–Ω–æ–ø–∫–∏ '{inline_text}'.\n–í–≤–µ–¥–∏—Ç–µ –Ω–∞–∑–≤–∞–Ω–∏–µ (label) –¥–ª—è —ç—Ç–æ–≥–æ –ø–æ–¥—Ä–∞–∑–¥–µ–ª–∞:")
        return

    if not (message.text.startswith("http") or message.text.startswith("tg://")):
        await message.answer("‚ùå –û—à–∏–±–∫–∞! –°—Å—ã–ª–∫–∞ –¥–æ–ª–∂–Ω–∞ –Ω–∞—á–∏–Ω–∞—Ç—å—Å—è —Å http –∏–ª–∏ tg://. –õ–∏–±–æ –≤—ã–±–µ—Ä–∏—Ç–µ '–ö–Ω–æ–ø–∫–∞ —Å –º–µ–Ω—é':",
                             reply_markup=ReplyKeyboardMarkup(keyboard=[[KeyboardButton(text="–ö–Ω–æ–ø–∫–∞ —Å –º–µ–Ω—é")], [KeyboardButton(text="‚¨ÖÔ∏è –û—Ç–º–µ–Ω–∞")]], resize_keyboard=True))
        return

    await state.update_data(inline_url=message.text)
    data = await state.get_data()
    await finalize_button_creation(message, state, data)

async def finalize_button_creation(message: types.Message, state: FSMContext, data: dict):
    label = data['label']
    content = data['content']
    photo = data.get('photo')
    inline_text = data.get('inline_text')
    inline_url = data.get('inline_url')
    parent_id = data.get('parent_id')
    is_nested = data.get('is_nested', False)

    print(f"\n[BOT_DEBUG] === finalize_button_creation Start ===")
    print(f"[BOT_DEBUG] Target: '{label}', Parent: '{parent_id}', Nested: {is_nested}")
    print(f"[BOT_DEBUG] Inline Text: '{inline_text}', URL: '{inline_url}'")

    buttons_json = None
    if inline_text:
        btn_data = {"text": inline_text}
        if is_nested:
            # –§–æ—Ä–º–∏—Ä—É–µ–º ID: —Ä–æ–¥–∏—Ç–µ–ª—å:–Ω–∞–∑–≤–∞–Ω–∏–µ
            nested_id = f"{label}:{inline_text}"
            btn_data["id"] = nested_id
            print(f"[BOT_DEBUG] Generated nested ID: '{nested_id}'")
            # –†–µ–≥–∏—Å—Ç—Ä–∏—Ä—É–µ–º –≤ —Å–ø–∏—Å–∫–µ —Ä–∞–∑—Ä–µ—à–µ–Ω–Ω—ã—Ö
            await add_keyboard_button(nested_id)
            # –°–æ—Ö—Ä–∞–Ω—è–µ–º –ø—É—Å—Ç—É—é –∑–∞–≥–ª—É—à–∫—É –¥–ª—è –≤–ª–æ–∂–µ–Ω–Ω–æ–≥–æ –º–µ–Ω—é
            await update_button_content(nested_id, f"–°–æ–¥–µ—Ä–∂–∏–º–æ–µ —Ä–∞–∑–¥–µ–ª–∞ '{inline_text}'", parent_id=label)
        else:
            btn_data["url"] = inline_url

        # –û–±–Ω–æ–≤–ª—è–µ–º —Å–ø–∏—Å–æ–∫ –∫–Ω–æ–ø–æ–∫ —É —Ä–æ–¥–∏—Ç–µ–ª—è
        existing = await get_button_content(label)
        current_btns = []
        if existing and existing.get('buttons_json'):
            try:
                current_btns = json.loads(existing['buttons_json'])
            except: pass

        # –î–æ–±–∞–≤–ª—è–µ–º –∏–ª–∏ –æ–±–Ω–æ–≤–ª—è–µ–º
        found = False
        for i, b in enumerate(current_btns):
            if b['text'] == inline_text:
                current_btns[i] = btn_data
                found = True
                break
        if not found:
            current_btns.append(btn_data)

        buttons_json = json.dumps(current_btns)

    # –°–æ—Ö—Ä–∞–Ω—è–µ–º –≤ Reply –∫–ª–∞–≤–∏–∞—Ç—É—Ä—É –µ—Å–ª–∏ —ç—Ç–æ –∫–æ—Ä–µ–Ω—å
    if not parent_id:
        print(f"[BOT_DEBUG] Adding root button '{label}' to Reply Keyboard")
        await add_keyboard_button(label)

    # –°–æ—Ö—Ä–∞–Ω—è–µ–º –∫–æ–Ω—Ç–µ–Ω—Ç –≤ –ë–î
    if await update_button_content(label, content, photo, buttons_json, parent_id=parent_id):
        print(f"[BOT_DEBUG] ‚úÖ finalized successfully")
        await message.answer(f"‚úÖ –ö–Ω–æ–ø–∫–∞ '{label}' —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∞!")
    else:
        print(f"[BOT_DEBUG] ‚ùå Failed to update content in DB")
        await message.answer("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–∏.")

    await state.clear()
    await manage_menu(message, state)

@router.message(F.text == "üìù –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –º–µ–Ω—é")
async def cmd_manage_menu(message: types.Message, state: FSMContext):
    if message.from_user.id != ADMIN_ID: return
    await manage_menu(message, state)


@router.message(F.text == "üîô –ù–∞–∑–∞–¥ –≤ –º–µ–Ω—é")
async def back_to_menu(message: types.Message, state: FSMContext):
    data = await state.get_data()
    current_menu = data.get('current_menu')
    current_submenu = data.get('current_submenu')

    # If in nested submenu, go back to parent submenu
    if current_submenu and current_menu:
        menu = MENU_STRUCTURE.get(current_menu)
        if menu and 'submenu' in menu:
            sub_menu = menu['submenu'].get(current_submenu)
            if sub_menu and 'submenu' in sub_menu:
                # Go back to submenu selection
                await state.update_data(current_submenu=None)
                keyboard = get_submenu_keyboard(current_menu, current_submenu)
                await message.answer(
                    sub_menu.get('text', '–í—ã–±–µ—Ä–∏—Ç–µ –æ–ø—Ü–∏—é:'),
                    reply_markup=keyboard,
                    parse_mode=ParseMode.HTML,
                    link_preview_options=LinkPreviewOptions(is_disabled=True))
                return

    # If in main submenu, go back to main menu
    if current_menu:
        await state.clear()
        keyboard = get_main_keyboard(message.from_user.id)
        await message.answer("–ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é:", reply_markup=keyboard)
        return

    # Default - show main menu
    await state.clear()
    keyboard = await get_dynamic_keyboard_async(message.from_user.id)
    await message.answer("–ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é:", reply_markup=keyboard)


@router.callback_query(F.data.startswith("main:"))
async def callback_main_section(query: types.CallbackQuery):
    """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ –¥–ª—è –∫–Ω–æ–ø–æ–∫ –∏–∑ inline —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤"""
    if not query.message:
        await query.answer("–û—à–∏–±–∫–∞ –¥–æ—Å—Ç—É–ø–∞ –∫ —Å–æ–æ–±—â–µ–Ω–∏—é")
        return

    # –ü–æ–ª—É—á–∞–µ–º –∫–ª—é—á —Ä–∞–∑–¥–µ–ª–∞ –∏–∑ callback_data (main:section_key)
    section_key = query.data[5:]  # –£–¥–∞–ª—è–µ–º –ø—Ä–µ—Ñ–∏–∫—Å "main:"

    # –ò—â–µ–º —Ä–∞–∑–¥–µ–ª –≤ –≥–ª–∞–≤–Ω–æ–º –º–µ–Ω—é
    section = MENU_STRUCTURE.get(section_key)

    if not section:
        await query.answer("–†–∞–∑–¥–µ–ª –Ω–µ –Ω–∞–π–¥–µ–Ω", show_alert=True)
        return

    # Log click statistics
    await log_click(section.get('label', section_key))

    try:
        # –ï—Å–ª–∏ –µ—Å—Ç—å submenu, –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –µ–≥–æ
        if 'submenu' in section:
            # –î–ª—è inline —Ä–µ–∂–∏–º–∞ –≤—Å–µ–≥–¥–∞ –∏—Å–ø–æ–ª—å–∑—É–µ–º inline –∫–ª–∞–≤–∏–∞—Ç—É—Ä—É
            keyboard = get_submenu_inline_keyboard(section_key)

            if query.message and isinstance(query.message, types.Message):
                await query.message.edit_text(
                    section.get('text', '–í—ã–±–µ—Ä–∏—Ç–µ –æ–ø—Ü–∏—é:'),
                    reply_markup=keyboard,
                    parse_mode=ParseMode.HTML,
                    link_preview_options=LinkPreviewOptions(is_disabled=True))
            else:
                await query.answer()
        # –ï—Å–ª–∏ –µ—Å—Ç—å pages, –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –ø–µ—Ä–≤—É—é —Å—Ç—Ä–∞–Ω–∏—Ü—É
        elif 'pages' in section:
            text_content = section['pages'][0].get('text', '')
            keyboard = get_nav_keyboard_inline(section_key, '', 0)

            if keyboard is None:
                # Fallback –µ—Å–ª–∏ keyboard –Ω–µ —Å–æ–∑–¥–∞–Ω–∞
                keyboard = InlineKeyboardMarkup(inline_keyboard=[[
                    InlineKeyboardButton(text="üîô –ù–∞–∑–∞–¥",
                                         callback_data="back_nav")
                ]])

            if query.message and isinstance(query.message, types.Message):
                await query.message.edit_text(
                    text_content,
                    reply_markup=keyboard,
                    parse_mode=ParseMode.HTML,
                    link_preview_options=LinkPreviewOptions(is_disabled=True))
            else:
                await query.answer()
        # –ò–Ω–∞—á–µ –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –ø—Ä–æ—Å—Ç–æ —Ç–µ–∫—Å—Ç —Å back –∫–Ω–æ–ø–∫–æ–π
        elif 'text' in section:
            keyboard = InlineKeyboardMarkup(inline_keyboard=[[
                InlineKeyboardButton(text="üîô –ù–∞–∑–∞–¥", callback_data="back_nav")
            ]])
            await query.message.edit_text(
                section['text'],
                reply_markup=keyboard,
                parse_mode=ParseMode.HTML,
                link_preview_options=LinkPreviewOptions(is_disabled=True))
    except Exception as e:
        logger.error(f"Error in callback_main_section: {e}")
        await query.answer("–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞", show_alert=True)

    await query.answer()


@router.callback_query(F.data == "main_menu")
async def callback_main_menu(query: types.CallbackQuery):
    if not query.message:
        return
    keyboard = get_main_keyboard(query.from_user.id)
    try:
        await query.message.edit_text("–ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é:")
    except Exception:
        pass
    await query.answer()


@router.callback_query(F.data == "noop")
async def callback_noop(query: types.CallbackQuery):
    await query.answer()




@router.callback_query(F.data == "back_nav")
async def callback_back_nav(query: types.CallbackQuery):
    # If no message, we're in inline mode - use inline_message_id
    if not query.message:
        logger.debug("Inline mode for back_nav")
        if query.inline_message_id:
            try:
                keyboard = get_main_keyboard(query.from_user.id)
                await bot.edit_message_text(
                    inline_message_id=query.inline_message_id,
                    text="–ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é:",
                    reply_markup=keyboard,
                    parse_mode=ParseMode.HTML)
                logger.info(f"‚úÖ Inline back_nav edited")
            except Exception as e:
                logger.error(f"Error in back_nav (inline): {e}")
        await query.answer()
        return

    # Extract parent from message text or go to main menu
    try:
        keyboard = get_main_keyboard(query.from_user.id)
        await query.message.edit_text("–ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é:",
                                      reply_markup=keyboard,
                                      parse_mode=ParseMode.HTML)
    except Exception as e:
        logger.error(f"Error in back_nav: {e}")
    await query.answer()


@router.callback_query(F.data.startswith("back_inline:"))
async def callback_back_inline(query: types.CallbackQuery):
    parent_key = query.data[12:]  # Extract parent key after "back_inline:"

    # Check if parent_key is a main menu item (first level)
    if parent_key in MENU_STRUCTURE:
        found_menu = MENU_STRUCTURE[parent_key]
        found_in_parent = None
        if found_menu.get("type") == "inline" and "submenu" in found_menu:
            # Add back button to return to main menu for first-level inline menus
            kb = get_inline_keyboard(found_menu["submenu"],
                                     parent_key,
                                     add_back_button=False)
            try:
                await edit_message_safe(
                    query, found_menu.get('text', '–í—ã–±–µ—Ä–∏—Ç–µ –æ–ø—Ü–∏—é:'), kb)
            except Exception as e:
                logger.error(f"Error in back_inline (first level): {e}")
            await query.answer()
            return

    # Deep search to find the parent menu in submenus
    found_menu = None
    found_in_parent = None

    # Specific fix for CPM and PDP range back buttons
    if parent_key == "info":
        found_in_parent = "garant_checker"
        found_menu = MENU_STRUCTURE["garant_checker"]["submenu"]["info"]
    elif parent_key == "chats":
        found_in_parent = None
        found_menu = MENU_STRUCTURE["chats"]
    elif parent_key in [
            "thematic_admin", "infobusiness", "general_admin", "business_chats"
    ]:
        found_in_parent = "chats"
        found_menu = MENU_STRUCTURE["chats"]["submenu"][parent_key]
    elif parent_key == "cpm_pdp":
        found_in_parent = None
        found_menu = MENU_STRUCTURE["cpm_pdp"]
    elif parent_key == "cpm_prices":
        found_in_parent = "cpm_pdp"
        found_menu = MENU_STRUCTURE["cpm_pdp"]["submenu"]["cpm_prices"]
    elif parent_key == "pdp_prices":
        found_in_parent = "cpm_pdp"
        found_menu = MENU_STRUCTURE["cpm_pdp"]["submenu"]["pdp_prices"]
    elif parent_key == "inline_cpm_pdp":
        found_in_parent = None
        found_menu = MENU_STRUCTURE["cpm_pdp"]
    elif parent_key in ["cpm_range_1", "cpm_range_2", "cpm_range_3"]:
        found_in_parent = "cpm_prices"
        found_menu = MENU_STRUCTURE["cpm_pdp"]["submenu"]["cpm_prices"][
            "submenu"][parent_key]
    elif parent_key in ["pdp_range_1", "pdp_range_2", "pdp_range_3"]:
        found_in_parent = "pdp_prices"
        found_menu = MENU_STRUCTURE["cpm_pdp"]["submenu"]["pdp_prices"][
            "submenu"][parent_key]
    else:
        for menu_key, menu_data in MENU_STRUCTURE.items():
            if "submenu" in menu_data:
                if parent_key in menu_data['submenu']:
                    found_menu = menu_data['submenu'][parent_key]
                    found_in_parent = menu_key
                    break
                # Search in nested submenus (second level)
                for sub_key, sub_menu in menu_data['submenu'].items():
                    if "submenu" in sub_menu and parent_key in sub_menu[
                            'submenu']:
                        found_menu = sub_menu['submenu'][parent_key]
                        found_in_parent = sub_key
                        break
            if found_menu:
                break

    if found_menu and found_menu.get(
            "type") == "inline" and "submenu" in found_menu:
        # Always show back button to return to parent
        show_back = True
        kb = get_inline_keyboard(found_menu["submenu"],
                                 parent_key,
                                 add_back_button=show_back)

        # Check if link preview should be disabled for this section
        is_link_preview_disabled = found_menu.get("link_preview") is False

        try:
            await edit_message_safe(
                query,
                found_menu.get('text', '–í—ã–±–µ—Ä–∏—Ç–µ –æ–ø—Ü–∏—é:'),
                kb,
                link_preview_disabled=is_link_preview_disabled)
        except Exception as e:
            # Ignore "message is not modified" errors - content and buttons are already correct
            if "message is not modified" not in str(e):
                logger.error(f"Error in back_inline (submenu): {e}")
        await query.answer()
        return

    # If we found the menu (but it's a leaf node/text content)
    if found_menu:
        # Create buttons
        buttons_list = []
        if found_menu.get('buttons'):
            for btn in found_menu['buttons']:
                buttons_list.append([
                    InlineKeyboardButton(text=btn['text'],
                                         callback_data=btn['callback'])
                ])
        else:
            # Default back button
            back_callback = f"back_inline:{found_in_parent}" if found_in_parent else "back_nav"
            buttons_list.append([
                InlineKeyboardButton(text="üîô –ù–∞–∑–∞–¥",
                                     callback_data=back_callback)
            ])

        keyboard = InlineKeyboardMarkup(inline_keyboard=buttons_list)

        try:
            await edit_message_safe(query,
                                    found_menu.get('text', '–ù–µ—Ç –æ–ø–∏—Å–∞–Ω–∏—è'),
                                    keyboard)
        except Exception as e:
            # Ignore "message is not modified" errors
            if "message is not modified" not in str(e):
                logger.error(f"Error in back_inline (no submenu): {e}")
    else:
        # Parent menu not found, go to main menu
        keyboard = get_main_keyboard(query.from_user.id)
        try:
            await edit_message_safe(query, "–ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é:", keyboard)
        except Exception as e:
            logger.error(f"Error in back_inline (main menu): {e}")

    await query.answer()


@router.callback_query(F.data.startswith("page:"))
async def callback_page_nav(query: types.CallbackQuery):
    logger.info(
        f"üìÑ Page navigation: {query.data}, has_message: {query.message is not None}, inline_id: {query.inline_message_id if hasattr(query, 'inline_message_id') else 'N/A'}"
    )

    if not query.data:
        logger.warning("Query data is None for page_nav")
        await query.answer()
        return

    parts = query.data.split(":")
    if len(parts) >= 4:
        menu_key = parts[1]
        sub_key = parts[2]
        try:
            page_index = int(parts[3])
        except (ValueError, IndexError):
            await query.answer()
            return

        logger.debug(
            f"Page nav: menu_key={menu_key}, sub_key={sub_key}, page_index={page_index}"
        )

        # Deep search for menu data
        menu = None

        # First try to get from main MENU_STRUCTURE by menu_key
        if menu_key and menu_key in MENU_STRUCTURE:
            menu = MENU_STRUCTURE[menu_key]
            # If this has pages and no sub_key specified, use it directly
            if 'pages' in menu and not sub_key:
                logger.debug(f"Found main menu with pages: {menu_key}")
            # Otherwise try to get submenu
            elif sub_key and 'submenu' in menu and sub_key in menu['submenu']:
                menu = menu['submenu'][sub_key]
                logger.debug(f"Found submenu: {menu_key}/{sub_key}")
        else:
            # Deep search for sub_key if menu_key not found
            logger.debug(f"Deep searching for sub_key: {sub_key}")
            for m_key, m_data in MENU_STRUCTURE.items():
                if m_key == sub_key:
                    menu = m_data
                    break
                if 'submenu' in m_data:
                    if sub_key in m_data['submenu']:
                        menu = m_data['submenu'][sub_key]
                        break
                    for s_key, s_data in m_data['submenu'].items():
                        if 'submenu' in s_data and sub_key in s_data['submenu']:
                            menu = s_data['submenu'][sub_key]
                            break
                if menu: break

        if not menu or 'pages' not in menu:
            logger.warning(
                f"Menu not found or no pages for menu_key={menu_key}, sub_key={sub_key}"
            )
            logger.debug(
                f"Available keys in MENU_STRUCTURE: {list(MENU_STRUCTURE.keys())}"
            )
            await query.answer()
            return

        pages = menu['pages']

        if 0 <= page_index < len(pages):
            page = pages[page_index]
            text = page.get('text') if isinstance(page, dict) else page
            keyboard = get_nav_keyboard_inline(menu_key, sub_key, page_index)

            logger.debug(
                f"Page content length: {len(text) if text else 0}, total pages: {len(pages)}"
            )

            # Handle both regular messages and inline messages
            if query.message:
                logger.debug("Editing regular message")
                try:
                    await query.message.edit_text(
                        text,
                        reply_markup=keyboard,
                        parse_mode=ParseMode.HTML,
                        link_preview_options=LinkPreviewOptions(
                            is_disabled=True))
                    logger.info(
                        f"‚úÖ Regular message edited, page {page_index + 1}/{len(pages)}"
                    )
                except Exception as e:
                    logger.error(
                        f"Error editing regular message: {type(e).__name__}: {e}"
                    )
            elif query.inline_message_id:
                logger.debug(
                    f"Editing inline message: {query.inline_message_id}")
                try:
                    await bot.edit_message_text(
                        inline_message_id=query.inline_message_id,
                        text=text,
                        reply_markup=keyboard,
                        parse_mode=ParseMode.HTML,
                        link_preview_options=LinkPreviewOptions(
                            is_disabled=True))
                    logger.info(
                        f"‚úÖ Inline message edited, page {page_index + 1}/{len(pages)}"
                    )
                except Exception as e:
                    logger.error(
                        f"Error editing inline message: {type(e).__name__}: {e}"
                    )
            else:
                logger.warning("No message or inline_message_id to edit")

    await query.answer()


def get_inline_keyboard(submenu_data,
                        parent_key="",
                        add_back_button=True,
                        first_button_full_width=False):
    keyboard = []

    # Custom layout for Garant Checker
    if parent_key == "garant_checker":
        # Info (Full width)
        if "info" in submenu_data:
            keyboard.append([
                InlineKeyboardButton(
                    text=submenu_data["info"]["label"],
                    callback_data="inline_garant_checker:info")
            ])
    elif parent_key == "info":
        # If we're inside info submenu, show exchanges and mammont buttons
        # Exchanges (Full width)
        if "exchanges" in submenu_data:
            keyboard.append([
                InlineKeyboardButton(text=submenu_data["exchanges"]["label"],
                                     callback_data="inline_info:exchanges")
            ])

        # Mammont 1 & 2 (Two columns)
        row = []
        if "mammontav1" in submenu_data:
            row.append(
                InlineKeyboardButton(text=submenu_data["mammontav1"]["label"],
                                     callback_data="inline_info:mammontav1"))
        if "mammontav2" in submenu_data:
            row.append(
                InlineKeyboardButton(text=submenu_data["mammontav2"]["label"],
                                     callback_data="inline_info:mammontav2"))
        if row:
            keyboard.append(row)
    elif parent_key == "chats":
        # Custom layout for Chats:
        # 1. –¢–µ–º–∞—Ç–∏—á–µ—Å–∫–∏–µ [–∞–¥–º–∏–Ω] (Full width)
        # 2. –ò–Ω—Ñ–æ–±–∏–∑ –∏ –æ–±—â–∏–µ [–∞–¥–º–∏–Ω] (Two columns)
        # 3. –ë–∏–∑–Ω–µ—Å (Full width)

        # –¢–µ–º–∞—Ç–∏—á–µ—Å–∫–∏–µ [–∞–¥–º–∏–Ω]
        if "thematic_admin" in submenu_data:
            keyboard.append([
                InlineKeyboardButton(
                    text=submenu_data["thematic_admin"]["label"],
                    callback_data="inline_chats:thematic_admin")
            ])

        # –ò–Ω—Ñ–æ–±–∏–∑ –∏ –æ–±—â–∏–µ [–∞–¥–º–∏–Ω] in one row
        row = []
        if "infobusiness" in submenu_data:
            row.append(
                InlineKeyboardButton(
                    text=submenu_data["infobusiness"]["label"],
                    callback_data="inline_chats:infobusiness"))
        if "general_admin" in submenu_data:
            row.append(
                InlineKeyboardButton(
                    text=submenu_data["general_admin"]["label"],
                    callback_data="inline_chats:general_admin"))
        if row:
            keyboard.append(row)

        # –ë–∏–∑–Ω–µ—Å
        if "business_chats" in submenu_data:
            keyboard.append([
                InlineKeyboardButton(
                    text=submenu_data["business_chats"]["label"],
                    callback_data="inline_chats:business_chats")
            ])
    else:
        # Default layout logic
        row = []
        items = list(submenu_data.items())

        for i, (sub_key, sub_menu) in enumerate(items):
            # Check if this is a URL button (like for stickers)
            if "url" in sub_menu:
                keyboard.append([
                    InlineKeyboardButton(text=sub_menu['label'],
                                         url=sub_menu['url'])
                ])
                continue

            callback_str = f"inline_{parent_key}:{sub_key}" if parent_key else f"inline_{sub_key}"
            button = InlineKeyboardButton(text=sub_menu['label'],
                                          callback_data=callback_str)

            if first_button_full_width and i == 0:
                keyboard.append([button])
            else:
                row.append(button)
                if len(row) == 2:
                    keyboard.append(row)
                    row = []
        if row:
            keyboard.append(row)

    # Add back button only if requested
    if add_back_button:
        # Special case: Remove back button when we are in the 'cpm_pdp' main menu
        if parent_key == "cpm_pdp":
            return InlineKeyboardMarkup(inline_keyboard=keyboard)

        # Ensure back button from prices leads to '—á—Ç–æ –≤–∞—Å –∏–Ω—Ç–µ—Ä–µ—Å—É–µ—Ç' (cpm_pdp)
        if parent_key in ["cpm_prices", "pdp_prices", "sticker_prices"]:
            back_callback = "back_inline:cpm_pdp"
        # Back button from info submenu should go to garant_checker
        elif parent_key == "info":
            back_callback = "back_inline:garant_checker"
        else:
            back_callback = f"back_inline:{parent_key}" if parent_key else "back_nav"

        keyboard.append([
            InlineKeyboardButton(text="üîô –ù–∞–∑–∞–¥", callback_data=back_callback)
        ])

    return InlineKeyboardMarkup(inline_keyboard=keyboard)


def get_submenu_inline_keyboard(menu_key, parent_sub_key=None):
    """–ü–æ–ª—É—á–∏—Ç—å inline –∫–ª–∞–≤–∏–∞—Ç—É—Ä—É –¥–ª—è submenu (–¥–ª—è inline —Ä–µ–∂–∏–º–∞)"""
    menu = MENU_STRUCTURE.get(menu_key)
    if not menu or 'submenu' not in menu:
        return None

    # If parent_sub_key is specified, get the nested submenu
    if parent_sub_key:
        sub_menu = menu['submenu'].get(parent_sub_key)
        if not sub_menu or 'submenu' not in sub_menu:
            return None
        submenu_dict = sub_menu['submenu']
        # For nested menus, we go back to the top-level menu item
        back_callback = f"inline_{menu_key}"
    else:
        submenu_dict = menu['submenu']
        # For top-level submenus, we go back to the main navigation (main menu)
        back_callback = "back_nav"

    keyboard = []
    row = []
    for sub_key, sub_menu in submenu_dict.items():
        callback_str = f"inline_{menu_key}:{sub_key}" if menu_key else f"inline_{sub_key}"
        row.append(
            InlineKeyboardButton(text=sub_menu['label'],
                                 callback_data=callback_str))
        if len(row) == 2:
            keyboard.append(row)
            row = []
    if row:
        keyboard.append(row)

    # Add back button ALWAYS for this function
    keyboard.append(
        [InlineKeyboardButton(text="üîô –ù–∞–∑–∞–¥", callback_data=back_callback)])

    return InlineKeyboardMarkup(inline_keyboard=keyboard)


@router.callback_query(F.data.startswith("support:"))
async def callback_support_button(query: types.CallbackQuery):
    """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–Ω–æ–ø–æ–∫ –ø–æ–¥–¥–µ—Ä–∂–∫–∏ –∏ –ø—Ä–æ–º–æ–∫–æ–¥–æ–≤"""
    support_data = query.data[8:]  # Remove 'support:' prefix

    support_texts = {
        "tgstat":
        "ü§ñ <b>–ü–æ–¥–¥–µ—Ä–∂–∫–∞</b>: @TGStatSupportBot\nüéÅ <b>–ü—Ä–æ–º–æ–∫–æ–¥</b>: <code>Lambarin</code> [5%]\n\n<a href=\"https://tgstat.ru/x/XXd7V\">–ü–µ—Ä–µ–π—Ç–∏ –Ω–∞ TGStat ‚Üí</a>",
        "telemetr":
        "ü§ñ <b>–ü–æ–¥–¥–µ—Ä–∂–∫–∞</b>: @TelemetrSupport\nüéÅ <b>–ü—Ä–æ–º–æ–∫–æ–¥</b>: <code>Lambarin</code> [10%]\n\n<a href=\"https://telemetr.me/\">–ü–µ—Ä–µ–π—Ç–∏ –Ω–∞ Telemetr ‚Üí</a>",
        "trustat":
        "ü§ñ <b>–ü–æ–¥–¥–µ—Ä–∂–∫–∞</b>: @TrustatSupport\n\n<a href=\"https://t.me/trustat\">–ü–µ—Ä–µ–π—Ç–∏ –Ω–∞ Trustat ‚Üí</a>",
        "botstat":
        "ü§ñ <b>–ü–æ–¥–¥–µ—Ä–∂–∫–∞</b>: @botstatcontact\n\n<a href=\"https://botstat.io/\">–ü–µ—Ä–µ–π—Ç–∏ –Ω–∞ BotStat ‚Üí</a>"
    }

    support_text = support_texts.get(support_data, "–ü–æ–¥–¥–µ—Ä–∂–∫–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–∞")
    back_callback = f"inline_{support_data}"

    keyboard = InlineKeyboardMarkup(inline_keyboard=[[
        InlineKeyboardButton(text="üîô –ù–∞–∑–∞–¥ –∫ –æ–ø–∏—Å–∞–Ω–∏—é",
                             callback_data=back_callback)
    ]])

    try:
        await edit_message_safe(query,
                                support_text,
                                keyboard,
                                link_preview_disabled=True)
    except Exception as e:
        logger.error(f"Error in support button: {e}")

    await query.answer()


@router.callback_query(F.data.startswith("inline_"))
async def callback_inline_button(query: types.CallbackQuery,
                                 state: FSMContext):
    logger.info(
        f"üîò Inline button pressed: {query.data}, user_id: {query.from_user.id}, has_message: {query.message is not None}"
    )

    # Parse callback data - could be "inline_child" or "inline_parent:child"
    callback_data = query.data[7:]  # Remove 'inline_' prefix
    logger.debug(f"Parsed callback_data: {callback_data}")

    if ':' in callback_data:
        parent_key, sub_key = callback_data.split(':', 1)
    else:
        parent_key = ""
        sub_key = callback_data

    logger.debug(f"parent_key: {parent_key}, sub_key: {sub_key}")

    # Deep search function to find menu data by key and track hierarchy
    def find_hierarchy(submenu_data, target_key, path=None):
        if path is None: path = []
        if not submenu_data:
            return None
        if target_key in submenu_data:
            return {"menu": submenu_data[target_key], "path": path}
        for key, value in submenu_data.items():
            if isinstance(value, dict) and "submenu" in value:
                res = find_hierarchy(value["submenu"], target_key,
                                     path + [key])
                if res:
                    return res
        return None

    found_hierarchy = None
    top_parent = ""
    for menu_key, menu_data in MENU_STRUCTURE.items():
        if "submenu" in menu_data:
            found_hierarchy = find_hierarchy(menu_data["submenu"], sub_key)
            if found_hierarchy:
                top_parent = menu_key
                break

    if not found_hierarchy:
        logger.warning(f"Menu not found for sub_key: {sub_key}")
        await query.answer("–†–∞–∑–¥–µ–ª –Ω–µ –Ω–∞–π–¥–µ–Ω", show_alert=True)
        return

    found_menu = found_hierarchy["menu"]
    path = found_hierarchy["path"]

    # Log click statistics
    await log_click(found_menu.get('label', sub_key))

    # Determine the real parent for the back button
    if path:
        # If we have a path, the parent is the last item in the path
        effective_parent = path[-1]
    else:
        # If no path, the parent is the top-level MENU_STRUCTURE key
        effective_parent = top_parent

    logger.debug(
        f"Hierarchy found. Top: {top_parent}, Path: {path}, Effective Parent: {effective_parent}"
    )

    logger.debug(
        f"Found menu, has_pages: {'pages' in found_menu}, has_submenu: {'submenu' in found_menu}"
    )

    # If no message, we're in inline mode - try to edit inline message
    if not query.message:
        logger.debug(f"No message - checking for inline_message_id")
        logger.debug(
            f"inline_message_id: {query.inline_message_id if hasattr(query, 'inline_message_id') else 'N/A'}"
        )

        # Get text content based on menu type
        if 'pages' in found_menu:
            logger.debug("Using pages content")
            text_content = found_menu['pages'][0].get('text', '–ù–µ—Ç –æ–ø–∏—Å–∞–Ω–∏—è')
            keyboard = get_nav_keyboard_inline('', sub_key, 0)
        elif found_menu.get("type") == "inline" and "submenu" in found_menu:
            logger.debug("Using inline submenu")
            text_content = found_menu.get('text', '–í—ã–±–µ—Ä–∏—Ç–µ –æ–ø—Ü–∏—é:')
            # Only show back button if this is NOT a first-level menu item
            show_back = sub_key not in MENU_STRUCTURE
            keyboard = get_inline_keyboard(found_menu["submenu"],
                                           sub_key,
                                           add_back_button=show_back)
        else:
            logger.debug("Using simple text content")
            logger.debug("Using simple text content")
            text_content = found_menu.get('text', '–ù–µ—Ç –æ–ø–∏—Å–∞–Ω–∏—è')
            # Create buttons
            buttons_list = []
            if found_menu.get('buttons'):
                for btn in found_menu['buttons']:
                    buttons_list.append([
                        InlineKeyboardButton(text=btn['text'],
                                             callback_data=btn['callback'])
                    ])
            # Add back button ONLY if not already present in found_menu['buttons']
            back_callback = f"back_inline:{effective_parent}"
            has_back = False
            if found_menu.get('buttons'):
                for btn in found_menu['buttons']:
                    if "–ù–∞–∑–∞–¥" in btn.get('text', '') or "back" in btn.get(
                            'callback', ''):
                        has_back = True
                        break

            if not has_back:
                buttons_list.append([
                    InlineKeyboardButton(text="üîô –ù–∞–∑–∞–¥",
                                         callback_data=back_callback)
                ])
            keyboard = InlineKeyboardMarkup(inline_keyboard=buttons_list)

        # Try to edit inline message if we have inline_message_id
        if query.inline_message_id:
            logger.info(f"üìù Editing inline message: {query.inline_message_id}")
            try:
                await bot.edit_message_text(
                    inline_message_id=query.inline_message_id,
                    text=text_content,
                    reply_markup=keyboard,
                    parse_mode=ParseMode.HTML,
                    link_preview_options=LinkPreviewOptions(is_disabled=True))
                logger.info(f"‚úÖ Inline message edited successfully")
            except Exception as e:
                logger.error(
                    f"‚ùå Error editing inline message: {type(e).__name__}: {e}")
        else:
            logger.debug(f"No inline_message_id available, just answering")

        await query.answer()
        return

    # If found_menu has pages, show navigation
    if 'pages' in found_menu:
        text_content = found_menu['pages'][0].get('text', '')
        keyboard = get_nav_keyboard_inline('', sub_key, 0)

        if not keyboard:
            keyboard = InlineKeyboardMarkup(inline_keyboard=[[
                InlineKeyboardButton(text="üîô –ù–∞–∑–∞–¥", callback_data="back_nav")
            ]])

        try:
            await query.message.edit_text(
                text_content,
                reply_markup=keyboard,
                parse_mode=ParseMode.HTML,
                link_preview_options=LinkPreviewOptions(is_disabled=True))
        except Exception as e:
            logger.error(f"Error editing message in pages: {e}")
            try:
                await query.answer("–û—à–∏–±–∫–∞ –ø—Ä–∏ —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏–∏ —Å–æ–æ–±—â–µ–Ω–∏—è",
                                   show_alert=True)
            except:
                pass
    # Check if the found menu item itself has an inline submenu to show
    elif found_menu.get("type") == "inline" and "submenu" in found_menu:
        # Only show back button if this is NOT a first-level menu item
        show_back = sub_key not in MENU_STRUCTURE
        kb = get_inline_keyboard(found_menu["submenu"],
                                 sub_key,
                                 add_back_button=show_back)
        try:
            await query.message.edit_text(
                found_menu.get('text', '–í—ã–±–µ—Ä–∏—Ç–µ –æ–ø—Ü–∏—é:'),
                reply_markup=kb,
                parse_mode=ParseMode.HTML,
                link_preview_options=LinkPreviewOptions(is_disabled=True))
        except Exception as e:
            logger.error(f"Error editing message in submenu: {e}")
            try:
                await query.answer("–û—à–∏–±–∫–∞ –ø—Ä–∏ —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏–∏ —Å–æ–æ–±—â–µ–Ω–∏—è",
                                   show_alert=True)
            except:
                pass
    else:
        text = found_menu.get('text', '–ù–µ—Ç –æ–ø–∏—Å–∞–Ω–∏—è')
        # Handle markdown-style links if they exist
        import re
        text = re.sub(r'\*\*(.*?)\*\*', r'<b>\1</b>', text)
        text = re.sub(r'\[(.*?)\]\((.*?)\)', r'<a href="\2">\1</a>', text)

        # Create buttons - support buttons + back button
        buttons_list = []
        if found_menu.get('buttons'):
            for btn in found_menu['buttons']:
                buttons_list.append([
                    InlineKeyboardButton(text=btn['text'],
                                         callback_data=btn['callback'])
                ])

        # Add back button ONLY if not already present in found_menu['buttons']
        back_callback = f"back_inline:{effective_parent}"
        has_back = False
        if found_menu.get('buttons'):
            for btn in found_menu['buttons']:
                if "–ù–∞–∑–∞–¥" in btn.get('text', '') or "back" in btn.get(
                        'callback', ''):
                    has_back = True
                    break

        if not has_back:
            buttons_list.append([
                InlineKeyboardButton(text="üîô –ù–∞–∑–∞–¥",
                                     callback_data=back_callback)
            ])

        keyboard = InlineKeyboardMarkup(inline_keyboard=buttons_list)
        try:
            await query.message.edit_text(
                text,
                reply_markup=keyboard,
                parse_mode=ParseMode.HTML,
                link_preview_options=LinkPreviewOptions(is_disabled=True))
        except Exception as e:
            logger.error(f"Error editing message in text: {e}")
            try:
                await query.answer("–û—à–∏–±–∫–∞ –ø—Ä–∏ —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏–∏ —Å–æ–æ–±—â–µ–Ω–∏—è",
                                   show_alert=True)
            except:
                pass

    await query.answer()


async def handle_button_click(message: types.Message, state: FSMContext):
    if not message or not message.text:
        return

    current_state = await state.get_state()
    if current_state:
        return

    text = message.text

    # Check if it's a main menu button
    for menu_key, menu_data in MENU_STRUCTURE.items():
        if menu_data.get('label') and text.strip().lower(
        ) == menu_data['label'].strip().lower():
            # Log click statistics
            await log_click(menu_data['label'])

            # Check for dynamic content
            db_content = await get_button_content(menu_data['label'])
            if db_content:
                msg_text = db_content['content']
                photo = db_content['photo_file_id']
                kb = None
                if db_content['buttons_json']:
                    btns = json.loads(db_content['buttons_json'])
                    kb = InlineKeyboardMarkup(inline_keyboard=[[InlineKeyboardButton(text=b['text'], url=b['url'])] for b in btns])

                if photo:
                    await message.answer_photo(photo, caption=msg_text, reply_markup=kb, parse_mode=ParseMode.HTML)
                else:
                    await message.answer(msg_text, reply_markup=kb, parse_mode=ParseMode.HTML)
                return

            await state.set_state(None)

            # If has submenu, show submenu
            if 'submenu' in menu_data:
                if menu_data.get("type") == "inline":
                    # Don't add back button for first-level menus (sites, chats, bots, cpm_pdp, garant_checker, analytics_services)
                    # For garant_checker, make first button (exchanges) full width
                    first_button_full_width = (menu_key == "garant_checker")
                    keyboard = get_inline_keyboard(
                        menu_data["submenu"],
                        menu_key,
                        add_back_button=False,
                        first_button_full_width=first_button_full_width)
                    await message.answer(
                        menu_data.get('text', '–í—ã–±–µ—Ä–∏—Ç–µ –æ–ø—Ü–∏—é:'),
                        reply_markup=keyboard,
                        parse_mode=ParseMode.HTML,
                        link_preview_options=LinkPreviewOptions(
                            is_disabled=True))
                else:
                    keyboard = get_submenu_keyboard(menu_key)
                    await state.update_data(current_menu=menu_key)
                    await message.answer(
                        menu_data.get('text', '–í—ã–±–µ—Ä–∏—Ç–µ –æ–ø—Ü–∏—é:'),
                        reply_markup=keyboard,
                        parse_mode=ParseMode.HTML,
                        link_preview_options=LinkPreviewOptions(
                            is_disabled=True))
                return

            # If has pages, show first page with navigation
            elif 'pages' in menu_data:
                text_content = menu_data['pages'][0].get('text', '')
                keyboard = get_nav_keyboard_inline(menu_key, '', 0)
                await message.answer(
                    text_content,
                    reply_markup=keyboard,
                    parse_mode=ParseMode.HTML,
                    link_preview_options=LinkPreviewOptions(is_disabled=True))
                return

            # Otherwise just show text
            elif 'text' in menu_data:
                keyboard = get_main_keyboard(message.from_user.id)
                await message.answer(
                    menu_data['text'],
                    reply_markup=keyboard,
                    parse_mode=ParseMode.HTML,
                    link_preview_options=LinkPreviewOptions(is_disabled=True))
                return

    # Check if it's a submenu button
    data = await state.get_data()
    current_menu = data.get('current_menu')
    current_submenu = data.get('current_submenu')

    if current_menu:
        menu = MENU_STRUCTURE.get(current_menu)
        if menu and 'submenu' in menu:
            # If we're in a nested submenu level
            if current_submenu:
                parent_sub = menu['submenu'].get(current_submenu)
                if parent_sub and 'submenu' in parent_sub:
                    for sub_key, sub_menu in parent_sub['submenu'].items():
                        if sub_menu.get('label') and text.strip().lower(
                        ) == sub_menu['label'].strip().lower():
                            # Log click statistics
                            await log_click(sub_menu['label'])

                            # Check for dynamic content
                            db_content = await get_button_content(sub_menu['label'])
                            if db_content:
                                msg_text = db_content['content']
                                photo = db_content['photo_file_id']
                                kb = None
                                if db_content['buttons_json']:
                                    btns = json.loads(db_content['buttons_json'])
                                    kb = InlineKeyboardMarkup(inline_keyboard=[[InlineKeyboardButton(text=b['text'], url=b['url'])] for b in btns])

                                if photo:
                                    await message.answer_photo(photo, caption=msg_text, reply_markup=kb, parse_mode=ParseMode.HTML)
                                else:
                                    await message.answer(msg_text, reply_markup=kb, parse_mode=ParseMode.HTML)
                                return

                            # If nested submenu has pages, show navigation
                            if 'pages' in sub_menu:
                                text_content = sub_menu['pages'][0].get(
                                    'text', '')
                                keyboard = get_nav_keyboard_inline(
                                    current_menu, sub_key, 0)
                                await message.answer(
                                    text_content,
                                    reply_markup=keyboard,
                                    parse_mode=ParseMode.HTML,
                                    link_preview_options=LinkPreviewOptions(
                                        is_disabled=True))
                                return

                            # Otherwise just show text
                            elif 'text' in sub_menu:
                                keyboard = get_submenu_keyboard(
                                    current_menu, current_submenu)
                                await message.answer(
                                    sub_menu['text'],
                                    reply_markup=keyboard,
                                    parse_mode=ParseMode.HTML,
                                    link_preview_options=LinkPreviewOptions(
                                        is_disabled=True))
                                return
            else:
                # First level submenu
                for sub_key, sub_menu in menu['submenu'].items():
                    if sub_menu.get('label') and text.strip().lower(
                    ) == sub_menu['label'].strip().lower():
                        # Log click statistics
                        await log_click(sub_menu['label'])

                        # Check for dynamic content
                        db_content = await get_button_content(sub_menu['label'])
                        if db_content:
                            msg_text = db_content['content']
                            photo = db_content['photo_file_id']
                            kb = None
                            if db_content['buttons_json']:
                                btns = json.loads(db_content['buttons_json'])
                                kb = InlineKeyboardMarkup(inline_keyboard=[[InlineKeyboardButton(text=b['text'], url=b['url'])] for b in btns])

                            if photo:
                                await message.answer_photo(photo, caption=msg_text, reply_markup=kb, parse_mode=ParseMode.HTML)
                            else:
                                await message.answer(msg_text, reply_markup=kb, parse_mode=ParseMode.HTML)
                            return

                        # If this submenu has nested submenus, show them
                        if 'submenu' in sub_menu:
                            if sub_menu.get("type") == "inline":
                                # Don't add back button for first-level submenus
                                keyboard = get_inline_keyboard(
                                    sub_menu["submenu"],
                                    sub_key,
                                    add_back_button=False)
                                await message.answer(
                                    sub_menu.get('text', f"–í—ã–±–µ—Ä–∏—Ç–µ –æ–ø—Ü–∏—é:"),
                                    reply_markup=keyboard,
                                    parse_mode=ParseMode.HTML,
                                    link_preview_options=LinkPreviewOptions(
                                        is_disabled=True))
                            else:
                                keyboard = get_submenu_keyboard(
                                    current_menu, sub_key)
                                await state.update_data(current_submenu=sub_key
                                                        )
                                await message.answer(
                                    sub_menu.get('text', f"–í—ã–±–µ—Ä–∏—Ç–µ –æ–ø—Ü–∏—é:"),
                                    reply_markup=keyboard,
                                    parse_mode=ParseMode.HTML,
                                    link_preview_options=LinkPreviewOptions(
                                        is_disabled=True))
                            return

                        # If submenu has pages, show navigation
                        elif 'pages' in sub_menu:
                            text_content = sub_menu['pages'][0].get('text', '')
                            keyboard = get_nav_keyboard_inline(
                                current_menu, sub_key, 0)
                            await message.answer(
                                text_content,
                                reply_markup=keyboard,
                                parse_mode=ParseMode.HTML,
                                link_preview_options=LinkPreviewOptions(
                                    is_disabled=True))
                            return

                        # Otherwise just show text
                        elif 'text' in sub_menu:
                            keyboard = get_submenu_keyboard(current_menu)
                            await message.answer(
                                sub_menu['text'],
                                reply_markup=keyboard,
                                parse_mode=ParseMode.HTML,
                                link_preview_options=LinkPreviewOptions(
                                    is_disabled=True))
                            return

    # If not recognized, show main menu
    await state.clear()
    keyboard = await get_dynamic_keyboard(message.from_user.id)
    await message.answer("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–Ω–æ–ø–∫–∏ –º–µ–Ω—é:",
                         reply_markup=keyboard)


@router.inline_query()
async def inline_query_handler(inline_query: InlineQuery):
    """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ inline —Ä–µ–∂–∏–º–∞ –∫–æ–≥–¥–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –ø–∏—à–µ—Ç @bot_username"""
    import re

    query = inline_query.query.lower().strip()
    results = []

    # –ò—â–µ–º –ø–æ –≤—Å–µ–º —Ä–∞–∑–¥–µ–ª–∞–º –≥–ª–∞–≤–Ω–æ–≥–æ –º–µ–Ω—é
    search_sections = [
        "garant_checker", "terminology", "cpm_pdp", "analytics", "chats",
        "bots", "useful_sites", "promo_codes"
    ]

    for section_key in search_sections:
        section = MENU_STRUCTURE.get(section_key)
        if not section:
            continue

        label = section.get('label', '').lower()

        # –ï—Å–ª–∏ –Ω–∞–π–¥–µ–Ω–æ –≤ –Ω–∞–∑–≤–∞–Ω–∏–∏ —Ä–∞–∑–¥–µ–ª–∞ –∏–ª–∏ query –ø—É—Å—Ç
        if query in label or not query:
            # –ü–æ–ª—É—á–∞–µ–º –ø–æ–ª–Ω—ã–π —Ç–µ–∫—Å—Ç —Ä–∞–∑–¥–µ–ª–∞ - –æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ –Ω–µ–ø—É—Å—Ç–æ–π
            full_text = section.get('text', '')
            title = section.get('label', '')

            # –ï—Å–ª–∏ –Ω–µ—Ç —Ç–µ–∫—Å—Ç–∞, –ø—Ä–æ–≤–µ—Ä—è–µ–º —Å—Ç—Ä–∞–Ω–∏—Ü—ã (–¥–ª—è "–¢–µ—Ä–º–∏–Ω–æ–ª–æ–≥–∏—è" –∏ –ø–æ–¥–æ–±–Ω—ã—Ö)
            if not full_text or not full_text.strip():
                if 'pages' in section and section['pages']:
                    # –ë–µ—Ä—ë–º —Ç–µ–∫—Å—Ç –ø–µ—Ä–≤–æ–π —Å—Ç—Ä–∞–Ω–∏—Ü—ã
                    first_page = section['pages'][0]
                    if isinstance(first_page, dict):
                        full_text = first_page.get('text', '')
                    else:
                        full_text = first_page

            # –ì–∞—Ä–∞–Ω—Ç–∏—Ä—É–µ–º, —á—Ç–æ –µ—Å—Ç—å —Ç–µ–∫—Å—Ç –¥–ª—è –æ—Ç–ø—Ä–∞–≤–∫–∏
            if not full_text or not full_text.strip():
                full_text = title if title else '–†–∞–∑–¥–µ–ª'

            # –£–±–∏—Ä–∞–µ–º HTML —Ç–µ–≥–∏ —Ç–æ–ª—å–∫–æ –¥–ª—è –æ–ø–∏—Å–∞–Ω–∏—è (preview)
            clean_text = re.sub(r'<[^>]+>', '', full_text)
            description = clean_text[:100] if clean_text else title

            # –§–∏–Ω–∞–ª—å–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ - —Ç–µ–∫—Å—Ç –Ω–µ –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –ø—É—Å—Ç—ã–º
            final_text = full_text.strip() if full_text else title
            if not final_text:
                final_text = '–†–∞–∑–¥–µ–ª'

            # –°–æ–∑–¥–∞–µ–º –∫–ª–∞–≤–∏–∞—Ç—É—Ä—É —Å –∫–Ω–æ–ø–∫–∞–º–∏ –∫–∞–∫ –≤ –æ—Å–Ω–æ–≤–Ω–æ–º –±–æ—Ç–µ
            keyboard = InlineKeyboardMarkup(inline_keyboard=[[
                InlineKeyboardButton(text="üîô –ù–∞–∑–∞–¥", callback_data="back_nav")
            ]])  # Default - back button

            # –ï—Å–ª–∏ –µ—Å—Ç—å submenu, –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –∫–Ω–æ–ø–∫–∏ submenu
            if 'submenu' in section:
                submenu_keyboard = get_inline_keyboard(section["submenu"],
                                                       section_key,
                                                       add_back_button=False)
                if submenu_keyboard:
                    keyboard = submenu_keyboard
            # –î–ª—è –ø—Ä–æ–º–æ–∫–æ–¥–æ–≤ —É–±–∏—Ä–∞–µ–º –∫–Ω–æ–ø–∫—É "–ù–∞–∑–∞–¥" –≤ –∏–Ω–ª–∞–π–Ω —Ä–µ–∂–∏–º–µ
            elif section_key == "promo_codes":
                keyboard = InlineKeyboardMarkup(inline_keyboard=[])
            # –ï—Å–ª–∏ –µ—Å—Ç—å pages, –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –∫–Ω–æ–ø–∫–∏ –Ω–∞–≤–∏–≥–∞—Ü–∏–∏
            elif 'pages' in section:
                nav_keyboard = get_nav_keyboard_inline(section_key, '', 0)
                if nav_keyboard:
                    keyboard = nav_keyboard

            # –£–Ω–∏–∫–∞–ª—å–Ω—ã–π id - –∏–Ω–∞—á–µ Telegram –º–æ–∂–µ—Ç –∑–∞–∫–µ—à–∏—Ä–æ–≤–∞—Ç—å —Å—Ç–∞—Ä—ã–π —Ä–µ–∑—É–ª—å—Ç–∞—Ç
            unique_id = f"{section_key}_{hash(query or 'all')}"
            if len(unique_id) > 64:
                unique_id = unique_id[:64]

            try:
                result = InlineQueryResultArticle(
                    id=unique_id,
                    title=title if title else '–†–∞–∑–¥–µ–ª',
                    description=description if description else title,
                    input_message_content=InputTextMessageContent(
                        # –ü–æ–ª–Ω—ã–π —Ç–µ–∫—Å—Ç —Å HTML —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ–º - –æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ –Ω–µ–ø—É—Å—Ç–æ–π
                        message_text=final_text,
                        parse_mode=ParseMode.HTML,
                        link_preview_options=LinkPreviewOptions(
                            is_disabled=True)),
                    reply_markup=keyboard  # –ö–Ω–æ–ø–∫–∏ –∫–∞–∫ –≤ –æ–±—ã—á–Ω–æ–º –±–æ—Ç–µ
                )
                results.append(result)
            except Exception as e:
                logger.error(
                    f"Error creating inline result for {section_key}: {e}")
                continue

    # –í–°–ï–ì–î–ê –æ—Ç–≤–µ—á–∞–µ–º –Ω–∞ inline –∑–∞–ø—Ä–æ—Å (–æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ!)
    await inline_query.answer(
        results,
        cache_time=0,
        is_personal=True  # –ü–µ—Ä—Å–æ–Ω–∞–ª—å–Ω—ã–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã –¥–ª—è –∫–∞–∂–¥–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    )


# –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ –¥–∏–Ω–∞–º–∏—á–µ—Å–∫–∏—Ö –∫–Ω–æ–ø–æ–∫ (–ù–ï handler!)
async def handle_dynamic_buttons(message: types.Message, state: FSMContext):
    # –ü—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω—ã–π –≤—ã–≤–æ–¥ –≤ –∫–æ–Ω—Å–æ–ª—å –¥–ª—è –æ—Ç–ª–∞–¥–∫–∏
    print(f"\n[BOT_DEBUG] === handle_dynamic_buttons Start ===")
    print(f"[BOT_DEBUG] Text: '{message.text}'")
    print(f"[BOT_DEBUG] User ID: {message.from_user.id}")

    label = message.text
    if not label:
        print("[BOT_DEBUG] Message has no text, skipping.")
        return False

    # –ü—Ä–æ–≤–µ—Ä–∫–∞ —Ä–µ–∂–∏–º–∞ —É–¥–∞–ª–µ–Ω–∏—è –∫–Ω–æ–ø–æ–∫ –≤ –∞–¥–º–∏–Ω–∫–µ
    current_state = await state.get_state()
    print(f"[BOT_DEBUG] Current State: {current_state}")

    # 1. –ü—Ä–æ–≤–µ—Ä—è–µ–º –¥–∏–Ω–∞–º–∏—á–µ—Å–∫–∏–µ –∫–Ω–æ–ø–∫–∏ –∏–∑ –ë–î (–ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç)
    try:
        print(f"\n[BOT_DEBUG_VERBOSE] --- Step 1: DB Lookup ---")
        print(f"[BOT_DEBUG_VERBOSE] Searching content for label: '{label}'")
        # –°–Ω–∞—á–∞–ª–∞ –ø—Ä–æ–±—É–µ–º —Ç–æ—á–Ω–æ–µ —Å–æ–≤–ø–∞–¥–µ–Ω–∏–µ
        db_content = await get_button_content(label)

        # –ï—Å–ª–∏ –Ω–µ –Ω–∞—à–ª–∏, –ø—Ä–æ–±—É–µ–º –Ω–∞–π—Ç–∏ –ø–æ –≤—Å–µ–º –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã–º –∫–Ω–æ–ø–∫–∞–º –∫–ª–∞–≤–∏–∞—Ç—É—Ä—ã
        if not db_content:
            print(f"[BOT_DEBUG_VERBOSE] No exact match in button_content table for '{label}'")
            print(f"[BOT_DEBUG_VERBOSE] Fetching all registered keyboard labels...")
            all_btns = await get_all_keyboard_buttons()
            print(f"[BOT_DEBUG_VERBOSE] Total registered buttons in keyboard_buttons: {len(all_btns)}")
            for b in all_btns:
                b_lbl = b.get('label') if isinstance(b, dict) else (getattr(b, 'label', None) or b['label'] if hasattr(b, '__getitem__') else None)
                if b_lbl:
                    is_match = b_lbl.strip().lower() == label.strip().lower()
                    if is_match:
                        print(f"[BOT_DEBUG_VERBOSE] ‚úÖ Found fuzzy match: '{label}' -> '{b_lbl}'")
                        db_content = await get_button_content(b_lbl)
                        if db_content:
                            print(f"[BOT_DEBUG_VERBOSE] Successfully fetched content for fuzzy match '{b_lbl}'")
                            break
                    else:
                        # Log non-matches only in very verbose mode or skip
                        pass

        if db_content:
            print(f"[BOT_DEBUG_VERBOSE] ‚úÖ SUCCESS: Found DB entry for '{label}'")
            print(f"[BOT_DEBUG_VERBOSE] DB Button ID: '{db_content.get('button_id')}'")
            print(f"[BOT_DEBUG_VERBOSE] DB Parent ID: '{db_content.get('parent_id')}'")
            print(f"[BOT_DEBUG_VERBOSE] Content length: {len(db_content.get('content', ''))}")

            btn_id = db_content.get('button_id') or label
            await log_click(btn_id)

            msg_text = db_content.get('content', '')
            photo = db_content.get('photo_file_id')
            kb = None

            if db_content.get('buttons_json'):
                print(f"[BOT_DEBUG_VERBOSE] Found inline buttons JSON: {db_content['buttons_json']}")
                try:
                    btns = json.loads(db_content['buttons_json'])
                    print(f"[BOT_DEBUG_VERBOSE] Parsed {len(btns)} inline buttons")
                    inline_keyboard_list = []
                    for i, b in enumerate(btns):
                        btn_text = b.get('text', '???')
                        if b.get('url') and b.get('url') != '–º–µ–Ω—é':
                            print(f"[BOT_DEBUG_VERBOSE] Inline Button {i+1}: '{btn_text}' -> URL: {b['url']}")
                            inline_keyboard_list.append([InlineKeyboardButton(text=btn_text, url=b['url'])])
                        else:
                            target_id = b.get('id') or f"{btn_id}:{btn_text}"
                            print(f"[BOT_DEBUG_VERBOSE] Inline Button {i+1}: '{btn_text}' -> Submenu ID: {target_id}")
                            inline_keyboard_list.append([InlineKeyboardButton(text=btn_text, callback_data=f"dyn:{target_id}")])

                    if db_content.get('parent_id'):
                        parent_id = db_content['parent_id']
                        print(f"[BOT_DEBUG_VERBOSE] Adding 'Back' button to parent: '{parent_id}'")
                        inline_keyboard_list.append([InlineKeyboardButton(text="üîô –ù–∞–∑–∞–¥", callback_data=f"dyn:{parent_id}")])
                    else:
                        print(f"[BOT_DEBUG_VERBOSE] No parent_id found, back button will go to main menu if applicable")

                    kb = InlineKeyboardMarkup(inline_keyboard=inline_keyboard_list)
                except Exception as e:
                    print(f"[BOT_DEBUG_VERBOSE] ‚ùå ERROR parsing buttons_json: {e}")
            else:
                print(f"[BOT_DEBUG_VERBOSE] No inline buttons (buttons_json is empty)")

            if photo:
                print(f"[BOT_DEBUG_VERBOSE] Sending Photo response (File ID: {photo[:15]}...)")
                await message.answer_photo(photo, caption=msg_text, reply_markup=kb, parse_mode=ParseMode.HTML)
            else:
                print(f"[BOT_DEBUG_VERBOSE] Sending Text response")
                await message.answer(msg_text, reply_markup=kb, parse_mode=ParseMode.HTML)
            return True
        else:
            print(f"[BOT_DEBUG_VERBOSE] ‚ùå FAIL: Button '{label}' not found in button_content table after all attempts")
    except Exception as e:
        print(f"[BOT_DEBUG_VERBOSE] ‚ùå CRITICAL ERROR in handle_dynamic_buttons: {e}")
        import traceback
        traceback.print_exc()

    # 2. –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å—Ç–∞—Ç–∏—á–µ—Å–∫—É—é —Å—Ç—Ä—É–∫—Ç—É—Ä—É –º–µ–Ω—é
    print(f"[BOT_DEBUG] Step 2: Checking static menu structure")
    for key, item in MENU_STRUCTURE.items():
        if label.strip().lower() == item.get('label', '').strip().lower():
            print(f"[BOT_DEBUG] Found static match: {key}")
            await log_click(item.get('label'))

            # –°–æ–±–∏—Ä–∞–µ–º –∏–Ω–ª–∞–π–Ω-–∫–Ω–æ–ø–∫–∏ –∏–∑ –æ–±–æ–∏—Ö –∏—Å—Ç–æ—á–Ω–∏–∫–æ–≤
            inline_keyboard_list = []

            # 1. –°–Ω–∞—á–∞–ª–∞ –¥–æ–±–∞–≤–ª—è–µ–º –∫–Ω–æ–ø–∫–∏ –∏–∑ MENU_STRUCTURE
            if item.get('type') == 'inline' and item.get('submenu'):
                for skey, sub in item.get('submenu', {}).items():
                    inline_keyboard_list.append([
                        InlineKeyboardButton(text=sub['label'], callback_data=f"inline_{key}:{skey}")
                    ])

            # 2. –ó–∞—Ç–µ–º –¥–æ–±–∞–≤–ª—è–µ–º –∫–Ω–æ–ø–∫–∏ –∏–∑ –ë–î (–µ—Å–ª–∏ –µ—Å—Ç—å)
            db_content = await get_button_content(key)
            if db_content and db_content.get('buttons_json'):
                print(f"[BOT_DEBUG] Found DB inline buttons for static menu '{key}'")
                try:
                    btns = json.loads(db_content['buttons_json'])
                    for b in btns:
                        btn_text = b.get('text', '???')
                        if b.get('url') and b.get('url') != '–º–µ–Ω—é':
                            inline_keyboard_list.append([InlineKeyboardButton(text=btn_text, url=b['url'])])
                        else:
                            target_id = b.get('id') or f"{key}:{btn_text}"
                            inline_keyboard_list.append([InlineKeyboardButton(text=btn_text, callback_data=f"dyn:{target_id}")])
                except Exception as e:
                    print(f"[BOT_DEBUG] Error parsing DB buttons for static menu: {e}")

            # –§–æ—Ä–º–∏—Ä—É–µ–º –æ—Ç–≤–µ—Ç
            if inline_keyboard_list:
                kb = InlineKeyboardMarkup(inline_keyboard=inline_keyboard_list)
                await message.answer(item['text'], reply_markup=kb, parse_mode=ParseMode.HTML)
            elif 'pages' in item:
                kb = get_nav_keyboard_inline(key, "", 0)
                await message.answer(item['pages'][0]['text'], reply_markup=kb, parse_mode=ParseMode.HTML)
            else:
                await message.answer(item['text'], parse_mode=ParseMode.HTML)
            return True

    print(f"[BOT_DEBUG] === handle_dynamic_buttons End (No Match) ===")
    return False

    # 3. –†–µ–∑–µ—Ä–≤–Ω—ã–π –ø–æ–∏—Å–∫ –ø–æ –≤—Å–µ–º –∫–Ω–æ–ø–∫–∞–º –ë–î
    try:
        dynamic_btns = await get_all_keyboard_buttons()
        labels = [b['label'] for b in dynamic_btns]
        if label in labels:
            db_content = await get_button_content(label)
            if db_content:
                 # –ü–æ–≤—Ç–æ—Ä –ª–æ–≥–∏–∫–∏ –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è
                 msg_text = db_content['content']
                 photo = db_content['photo_file_id']
                 kb = None
                 if db_content['buttons_json']:
                     try:
                         btns = json.loads(db_content['buttons_json'])
                         inline_kb = []
                         for b in btns:
                             if b.get('url') and b.get('url') != '–º–µ–Ω—é':
                                 inline_kb.append([InlineKeyboardButton(text=b['text'], url=b['url'])])
                             else:
                                 b_id = b.get('id') or f"{label}:{b['text']}"
                                 inline_kb.append([InlineKeyboardButton(text=b['text'], callback_data=f"dyn:{b_id}")])
                         kb = InlineKeyboardMarkup(inline_keyboard=inline_kb)
                     except: pass

                 if photo:
                     await message.answer_photo(photo, caption=msg_text, reply_markup=kb, parse_mode=ParseMode.HTML)
                 else:
                     await message.answer(msg_text, reply_markup=kb, parse_mode=ParseMode.HTML)
                 return True
    except Exception as e:
        logger.error(f"Error in handle_dynamic_buttons (fallback search): {e}")
    return False

async def main():
    print("Starting bot...")
    await init_db()
    load_chats_continuation()

    # –û–¥–∏–Ω –≥–ª–∞–≤–Ω—ã–π –æ–±—Ä–∞–±–æ—Ç—á–∏–∫ –¥–ª—è –≤—Å–µ–≥–æ —Ç–µ–∫—Å—Ç–∞
    router.message.register(handle_all_text_messages, F.text)

    # Register handlers
    dp.include_router(router)

    await dp.start_polling(bot)


if __name__ == "__main__":
    asyncio.run(main())